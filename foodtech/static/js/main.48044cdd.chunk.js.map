{"version":3,"sources":["pages/Status/figure-2.svg","pages/Status/figure-3.svg","pages/Status/figure-4.svg","pages/Status/figure-6.svg","pages/Status/figure-7.svg","pages/Status/figure-8.svg","pages/Status/figure-9.svg","tools/history.js","stores/user.ts","stores/ui.ts","stores/product.ts","stores/products.ts","stores/cart.ts","stores/casts.ts","stores/index.ts","tools/connect.tsx","tools/bem.ts","hoc/withBem.tsx","components/Header/Header.tsx","components/HeaderAddress/HeaderAddress.tsx","tools/index.tsx","components/HeaderCart/HeaderCart.tsx","hooks/useFocusOnMount.tsx","components/Badge/Badge.tsx","pages/Catalog/ListItem/CatalogListItem.tsx","pages/Catalog/List/CatalogList.tsx","components/Skeleton/Skeleton.tsx","pages/Catalog/Skeleton/CatalogSkeleton.tsx","pages/Catalog/Catalog.tsx","components/Button/Button.tsx","pages/Cart/Info/CartInfo.tsx","pages/Cart/ListItem/CartListItem.tsx","pages/Cart/List/CartList.tsx","pages/Cart/Cart.tsx","pages/Status/Status.tsx","pages/Promo/Promo.tsx","hooks/useInterval.tsx","pages/NoArea/NoArea.tsx","pages/ScreenSaver/ScreenSaver.tsx","pages/AddressSimple/AddressSimple.tsx","components/Root/Root.tsx","tools/new-spatial-navigation.js","index.tsx","pages/Status/figure-1.svg"],"names":["module","exports","createHashHistory","User","types","model","address","maybeNull","string","location","phoneNumber","name","actions","self","updateUser","user","applySnapshot","routes","Ui","page","optional","enumeration","Object","values","SCREEN_SAVER","previous","ui","gotoPage","to","history","push","goToCart","CART","window","AssistantClient","sendData","action_id","ProductItem","id","identifier","clearName","price","number","imagesUrls","array","quantityLeft","Products","title","items","selectedId","CartItem","product","reference","count","Cart","orderId","views","reduce","acc","item","Math","floor","cart","clear","cast","addToCart","itemId","find","min","Number","removeFromCart","shouldRemoveMention","index","findIndex","max","splice","makePurchase","goTo","store","casts","SHOW_ITEMS","command","snapshot","stock","map","guid","clear_name","images_urls","quantity_left","products","ADD_ITEM","REMOVE_ITEM","REMOVE_ALL","GO_TO_VALIDATION","GO_TO_NO_AREA","NO_AREA","GO_TO_ADDRESS_SIMPLE","PROMO","GO_TO_CATALOG","address_string","CATALOG","VALIDATION_OK","STATUS","onMessage","message","smart_app_data","castFn","afterCreate","AssistantHost","ready","console","log","create","castFromStore","currentScreen","foodtech","keys","itemsMap","quantity","totalPrice","value","discountValue","undefined","__store","__inbox","__outbox","onStart","onData","JSON","stringify","onRequestState","state","updateState","connect","selector","baseComponent","component","ownProps","Error","useObserver","displayName","connectToStore","storeData","PREFIX","cssPrefix","blockName","delimeter","modDelimeter","renderer","elements","length","element","join","elem","mod","modVal","modify","conditions","elemToModify","entries","predicate","Boolean","filter","all","Component","componentName","props","context","bem","Bem","Header","withBem","children","className","HeaderAddress","tabIndex","onClick","ADDRESS_SIMPLE","splitByThousands","data","split","reduceRight","arr","HeaderCart","String","useFocusOnMount","ref","React","useRef","useLayoutEffect","current","HTMLElement","focus","contentMap","sale","backgroundMap","StyledBadge","styled","div","type","Badge","CatalogListItem","countInCart","mountRef","selected","setSelected","useState","isSoldOut","canAddMoreItems","badgeType","onBlur","onFocus","style","backgroundImage","CatalogList","mountFocusRef","key","Skeleton","itemWidth","itemHeight","borderRadius","rowCount","columnCount","paddingBetweenColumns","paddingBetweenRows","list","Array","from","_","columnIndex","rowIndex","x","y","width","height","rx","ry","CatalogSkeleton","viewBox","backgroundColor","foregroundColor","speed","Catalog","useEffect","process","StyledButton","button","Button","shouldFocusOnMount","CartInfo","hasPersonalData","big","small","disabled","MINIMAL_PRICE","addAddressInfo","CartListItem","onLessClick","onMoreClick","onSelect","setFocus","canAddMore","memoizedOnFocus","useCallback","aria-label","less","remove","more","onScroll","e","currentTarget","scrollTop","getOffset","itemsCount","relatedIndex","CartList","selectedItemIndex","setSelectedItemIndex","isFirstItemSelected","isLastItemSelected","wrapperStyle","transform","top","hidden","bottom","ceil","StatusButton","StatusContainer","StatusOrderNumber","StatusOrderTime","StatusFigure","StatusFirstFigure","FirstFigureIcon","StatusSecondFigure","SecondFigureIcon","StatusThirdFigure","ThirdFigureIcon","StatusFourthFigure","FourthFigureIcon","StatusFifthFigure","StatusSixthFigure","SixthFigureIcon","StatusSeventhFigure","SeventhFigureIcon","StatusEighthFigure","EighthFigureIcon","StatusNinthFigure","NinthFigureIcon","Status","Promo","currentIndex","setIndex","callback","timeout","POPCORN_TYPES_COUNT","intervalId","setInterval","clearInterval","NoArea","ScreenSaver","AddressSimple","Root","path","ARROW_KEY_CODE","37","38","39","40","mapOfBoundRect","startingPoint","savedSearchOrigin","rect","spatialNavigationHandler","addEventListener","currentKeyMode","parent","__spatialNavigation__","keyMode","eventTarget","document","activeElement","dir","keyCode","shiftKey","ctrlKey","metaKey","altKey","defaultPrevented","focusNavigableArrowKey","left","up","right","down","nodeName","startPosition","selectionStart","endPosition","selectionEnd","includes","getAttribute","handlingEditableElement","preventDefault","Map","navigate","clientX","clientY","target","getBoundingClientRect","searchOrigin","body","querySelector","elementStyle","getComputedStyle","invisibleStyle","getPropertyValue","documentElement","isVisibleInScroller","scroller","getScrollContainer","findSearchOrigin","elementFromPosition","elementFromPoint","isFocusable","isContainer","getSpatialNavigationContainer","container","contentDocument","bestInsideCandidate","spatialNavigationSearch","candidates","getSpatialNavigationCandidates","mode","focusingController","parentContainer","parentElement","navigateChain","bestCandidate","createSpatNavEvents","preventScroll","scrollingController","isScrollable","isScrollBoundary","moveScroll","isHTMLScrollBoundary","ownerDocument","option","childElementCount","getElementsByTagName","isDelegableContainer","concat","isVisible","getFilteredSpatialNavigationCandidates","targetElement","filteredCandidates","args","this","bestTarget","internalCandidates","externalCandidates","insideOverlappedCandidates","focusableAreas","overlappedCandidates","forEach","isEntirelyVisible","getOverlappedCandidates","defaultContainer","defaultCandidates","contains","candidate","fullyOverlapped","overlappedByParent","elm","flat","currentElm","getClosestElement","getDistanceFromPoint","getInnerDistance","selectBestCandidateFromEdge","selectBestCandidate","innerTarget","descendantsBest","indexOf","originalContainer","eventTargetRect","candidateRect","candidateBody","isOutside","isInside","spatialNavigationFunction","currentTargetRect","distanceFunction","alignedCandidates","isAligned","getAbsoluteDistance","getDistance","frameElement","minDistance","POSITIVE_INFINITY","minDistanceElements","i","distance","getEuclideanDistance","scrollContainer","isScrollContainer","focusables","prototype","call","eventType","containerElement","currentElement","direction","triggeredEvent","CustomEvent","bubbles","cancelable","detail","causedTarget","dispatchEvent","readCssVar","varName","trim","currentOption","nextContainer","offset","scrollLeft","isCSSSpatNavContain","overflowX","overflowY","isOverflow","scrollWidth","clientWidth","scrollHeight","clientHeight","result","winScrollY","winScrollX","abs","elementRect","nearestScroller","scrollerRect","DOMRect","innerWidth","innerHeight","tagName","isAtagWithoutHref","isActuallyDisabled","inert","isExpresslyInert","isVisibleStyleProperty","opacity","isBeingRendered","offsetX","parseInt","offsetWidth","offsetY","offsetHeight","isNaN","hitTestPoint","middle","leftTop","rightBottom","point","elemFromPoint","hitTest","containerRect","thisVisibility","childRect","rightEdgeCheck","leftEdgeCheck","topEdgeCheck","bottomEdgeCheck","rect1","rect2","isRightSide","isBelow","points","getEntryAndExitPoints","P1","entryPoint","exitPoint","P2","sqrt","pow","baseEdge","orthogonalBias","alignBias","A","B","C","intersectionRect","intersection_rect","area","new_location","new_max_point","getIntersectionRect","D","get","boundingClientRect","toFixed","set","enableExperimentalAPIs","getInitialAPIs","assign","canScroll","findTarget","findCandidate","bestNextTarget","isArray","findCandidates","bind","findNextTarget","getDistanceFromTarget","candidateElement","getExperimentalAPI","seal","_keymode","setStartingPoint","__getSpatNavState","searchOriginRect","Element","CSS","registerProperty","syntax","inherits","initialValue","requestAnimationFrame","async","scrollIntoView","behavior","block","inline","Promise","resolve","IntersectionObserver","entry","isIntersecting","threshold","observe","throttledClickToActiveElement","timeoutId","setTimeout","throttle","HTMLButtonElement","click","event","renderApp","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.48044cdd.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/figure-2.a3044c99.svg\";","module.exports = __webpack_public_path__ + \"static/media/figure-3.7084a68e.svg\";","module.exports = __webpack_public_path__ + \"static/media/figure-4.74f25c1b.svg\";","module.exports = __webpack_public_path__ + \"static/media/figure-6.1cf5f7c7.svg\";","module.exports = __webpack_public_path__ + \"static/media/figure-7.ef978761.svg\";","module.exports = __webpack_public_path__ + \"static/media/figure-8.dcc5e538.svg\";","module.exports = __webpack_public_path__ + \"static/media/figure-9.fb8b47f7.svg\";","import { createHashHistory } from 'history';\n\nexport default createHashHistory();\n","import { types, applySnapshot, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';\n\nconst User = types\n    .model('User', {\n        address: types.maybeNull(types.string),\n        location: types.maybeNull(types.string),\n        phoneNumber: types.maybeNull(types.string),\n        name: types.maybeNull(types.string),\n    })\n    .actions((self) => ({\n        updateUser: (user: Record<string, string>) => {\n            applySnapshot(self, { ...self, ...user });\n        },\n    }));\n\nexport default User;\n\nexport type UserSnapshotOut = SnapshotOut<typeof User>;\nexport type UserSnapshotIn = SnapshotIn<typeof User>;\nexport type UserModel = Instance<typeof User>;\n","import { types, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';\nimport history from 'tools/history';\n\nexport const SEARCH = 'SEARCH';\nexport const CATALOG = 'CATALOG';\nexport const CART = 'CART';\nexport const ADDRESS_SIMPLE = 'ADDRESS_SIMPLE';\nexport const STATUS = 'STATUS';\nexport const PROMO = 'PROMO';\nexport const NO_AREA = 'NO_AREA';\nexport const SCREEN_SAVER = 'SCREEN_SAVER';\n\nexport const routes = {\n    [SEARCH]: '/search',\n    [CATALOG]: '/catalog',\n    [CART]: '/cart',\n    [ADDRESS_SIMPLE]: '/address-simple',\n    [STATUS]: '/status',\n    [PROMO]: '/promo',\n    [NO_AREA]: '/no-area',\n    [SCREEN_SAVER]: '/screen-saver',\n};\n\nconst Ui = types\n    .model('Ui', {\n        page: types.optional(types.enumeration(Object.values(routes)), routes.SCREEN_SAVER),\n        previous: types.maybeNull(types.enumeration(Object.values(routes))),\n    })\n    .actions((self) => {\n        const ui = self;\n\n        const gotoPage = (to: string) => {\n            ui.previous = ui.page;\n            ui.page = to;\n            history.push(to);\n        };\n\n        const goToCart = () => {\n            gotoPage(routes.CART);\n\n            window.AssistantClient.sendData({\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                action_id: 'GO_TO_CART',\n            });\n        };\n\n        return {\n            gotoPage,\n            goToCart,\n        };\n    });\n\nexport type UiModel = Instance<typeof Ui>;\nexport type UiSnapshotOut = SnapshotOut<typeof Ui>;\nexport type UiSnapshotIn = SnapshotIn<typeof Ui>;\n\nexport default Ui;\n","import { types, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';\n\nconst ProductItem = types.model('Product', {\n    id: types.identifier,\n    name: types.string,\n    clearName: types.string,\n    price: types.number,\n    imagesUrls: types.array(types.string),\n    quantityLeft: types.string,\n});\n\nexport default ProductItem;\n\nexport type ProductItemSnapshotOut = SnapshotOut<typeof ProductItem>;\nexport type ProductItemSnapshotIn = SnapshotIn<typeof ProductItem>;\nexport type ProductItemModel = Instance<typeof ProductItem>;\n","import { types, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';\n\nimport ProductItem from './product';\n\nconst Products = types.model('Products', {\n    title: types.optional(types.string, ''),\n    items: types.array(ProductItem),\n    selectedId: types.maybeNull(types.string),\n});\n\nexport default Products;\n\nexport type ProductsModel = Instance<typeof Products>;\nexport type ProductsSnapshotOut = SnapshotOut<typeof Products>;\nexport type ProductsSnapshotIn = SnapshotIn<typeof Products>;\n","import { types, Instance, SnapshotIn, cast, SnapshotOut } from 'mobx-state-tree';\n\nimport ProductItem from './product';\n\nconst CartItem = types.model('CartItem', {\n    product: types.reference(ProductItem),\n    count: types.number,\n});\n\nexport type CartItemModel = Instance<typeof CartItem>;\n\nconst Cart = types\n    .model('Cart', {\n        items: types.array(CartItem),\n        orderId: types.maybeNull(types.string),\n    })\n    .views((self) => ({\n        get count(): number {\n            return self.items.reduce((acc: number, item: CartItemModel) => acc + item.count, 0);\n        },\n\n        get totalPrice(): number {\n            return self.items.reduce(\n                (acc: number, item: CartItemModel) => acc + Math.floor(item.product.price * item.count) / 100,\n                0,\n            );\n        },\n\n        get itemsMap(): { [key: string]: CartItemModel } {\n            return self.items.reduce((acc: Record<string, CartItemModel>, item: CartItemModel) => {\n                acc[item.product.id] = item;\n\n                return acc;\n            }, {});\n        },\n    }))\n    .actions((self) => {\n        const cart = self;\n\n        const addToCart = (itemId: string, count = 1) => {\n            const item = cart.items.find((item) => item.product.id === itemId);\n\n            if (item) {\n                item.count = Math.min(Number(item.product.quantityLeft), item.count + count);\n            } else {\n                cart.items.push({\n                    product: itemId,\n                    count,\n                });\n            }\n        };\n\n        const clear = (): void => {\n            cart.items = cast([]);\n        };\n\n        interface RemoveFromCartParams {\n            itemId: string;\n            count: number;\n            shouldRemoveMention?: boolean;\n        }\n\n        const removeFromCart = ({ itemId, count, shouldRemoveMention }: RemoveFromCartParams) => {\n            const index = cart.items.findIndex((item: CartItemModel) => item.product.id === itemId);\n            const item = cart.items[index];\n\n            if (!item) {\n                return;\n            }\n\n            item.count = Math.max(0, item.count - count);\n\n            if (!item.count && shouldRemoveMention) {\n                cart.items.splice(index, 1);\n            }\n        };\n\n        const makePurchase = () => {\n            window.AssistantClient.sendData({\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                action_id: 'MAKE_PURCHASE',\n            });\n\n            if (process.env.REACT_APP_ENVIRONMENT === 'development') {\n                window.AssistantClient.onData({\n                    type: 'smart_app_data',\n                    // eslint-disable-next-line @typescript-eslint/camelcase\n                    smart_app_data: {\n                        command: 'VALIDATION_OK',\n                        status: true,\n                        orderId: '364528',\n                    },\n                });\n            }\n        };\n\n        return {\n            clear,\n            addToCart,\n            removeFromCart,\n            makePurchase,\n        };\n    });\n\nexport type CartModel = Instance<typeof Cart>;\nexport type CartSnapshotOut = SnapshotOut<typeof Cart>;\nexport type CartSnapshotIn = SnapshotIn<typeof Cart>;\n\nexport default Cart;\n","import { applySnapshot } from 'mobx-state-tree';\n\nimport { StoreType } from './types';\nimport { routes } from './ui';\nimport { ProductsSnapshotIn } from './products';\nimport { ProductItemModel } from './product';\n\ninterface VpsStockItem {\n    name: string;\n    clear_name: string; // eslint-disable-line camelcase\n    guid: string;\n    price: string;\n    images_urls: string[]; // eslint-disable-line camelcase\n    quantity_left: string; // eslint-disable-line camelcase\n}\n\ninterface AddItemsCommand {\n    stock: VpsStockItem[];\n}\n\nconst showItemsCast = (store: StoreType, command: AddItemsCommand): void => {\n    const stock = Object.values(command.stock);\n    const items: ProductItemModel[] = stock.map((item: VpsStockItem) => ({\n        id: item.guid,\n        name: item.name,\n        clearName: item.clear_name,\n        price: Number(item.price),\n        imagesUrls: item.images_urls as ProductItemModel['imagesUrls'],\n        quantityLeft: item.quantity_left,\n    }));\n\n    const snapshot: ProductsSnapshotIn = {\n        title: 'Попкорн',\n        items,\n    };\n\n    applySnapshot(store.products, snapshot);\n};\n\ninterface VpsAddItem extends AssistantSdkCommand {\n    item: string;\n    count: string;\n}\n\nconst addItemCast = (store: StoreType, command: VpsAddItem): void => {\n    const { item: itemId, count } = command;\n\n    store.cart.addToCart(itemId, Number(count));\n};\n\ninterface RemoveItemFromCartCommand extends AssistantSdkCommand {\n    item: string;\n    count: string;\n}\n\nconst removeItem = (store: StoreType, { item, count }: RemoveItemFromCartCommand) =>\n    store.cart.removeFromCart({ itemId: item, count: Number(count), shouldRemoveMention: true });\n\nconst removeAll = (store: StoreType) => store.cart.clear();\n\nconst goTo = (page: string) => (store: StoreType) => store.ui.gotoPage(page);\n\ninterface GotoCatalogCommand extends AssistantSdkCommand {\n    clear: boolean;\n    address_string: string;\n}\n\nconst gotoCatalog = (store: StoreType, command: GotoCatalogCommand): void => {\n    if (command.clear) {\n        store.cart.clear();\n    }\n\n    store.user.address = command.address_string;\n\n    // чтобы при перезагрузке страницы постоянно не переходить в каталог\n    if (process.env.REACT_APP_ENVIRONMENT !== 'development') {\n        store.ui.gotoPage(routes.CATALOG);\n    }\n};\n\ninterface ValidationOkCommand extends AssistantSdkCommand {\n    orderId: string; // eslint-disable-line camelcase\n}\n\nconst success = (store: StoreType, command: ValidationOkCommand) => {\n    store.cart.orderId = command.orderId;\n    store.ui.gotoPage(routes.STATUS);\n};\n\nconst casts: { [key: string]: Function } = {\n    SHOW_ITEMS: showItemsCast,\n    ADD_ITEM: addItemCast,\n    REMOVE_ITEM: removeItem,\n    REMOVE_ALL: removeAll,\n    GO_TO_VALIDATION: goTo(routes.CART),\n    GO_TO_NO_AREA: goTo(routes.NO_AREA),\n    GO_TO_ADDRESS_SIMPLE: goTo(routes.PROMO),\n    GO_TO_CATALOG: gotoCatalog,\n    VALIDATION_OK: success,\n};\n\nexport default casts;\n","import { types } from 'mobx-state-tree';\nimport { USER_MOCK } from 'mocks';\n\nimport user from './user';\nimport ui, { routes } from './ui';\nimport products from './products';\nimport cart from './cart';\nimport { StoreType } from './types';\nimport casts from './casts';\n\nconst Store = types\n    .model('Store', {\n        ui: types.optional(ui, {}),\n        products: types.optional(products, {}),\n        cart: types.optional(cart, {}),\n        user: types.optional(user, {}),\n    })\n    .actions((self) => {\n        const store = self;\n\n        const afterCreate = function init() {\n            if (window.AssistantHost && typeof window.AssistantHost.ready === 'function') {\n                console.log('call ready native method');\n                window.AssistantHost.ready();\n            }\n\n            if (process.env.REACT_APP_ENVIRONMENT === 'development') {\n                setTimeout(() => {\n                    window.AssistantClient.onData({\n                        type: 'smart_app_data',\n                        // eslint-disable-next-line @typescript-eslint/camelcase\n                        smart_app_data: {\n                            command: 'GO_TO_CATALOG',\n                            // eslint-disable-next-line @typescript-eslint/camelcase\n                            address_string: USER_MOCK.address,\n                        },\n                    });\n                }, 0);\n            }\n        };\n\n        const onMessage = (message: AssistantSdkCommand): void => {\n            const { command } = message.smart_app_data;\n\n            if (command in casts) {\n                const castFn = casts[command];\n\n                castFn(store, message.smart_app_data);\n            }\n        };\n\n        return { onMessage, afterCreate };\n    });\n\nconst store = Store.create({});\n\n// eslint-disable-next-line no-underscore-dangle\nwindow.__store = store;\n\nfunction castFromStore(store: StoreType): AppStateInterface {\n    return {\n        currentScreen: store.ui.page === routes.CATALOG ? 'catalog' : 'cart', // eslint-disable-line\n        foodtech: {\n            products: Object.keys(store.cart.itemsMap).map((itemId) => ({\n                id: itemId,\n                quantity: store.cart.itemsMap[itemId].count,\n            })),\n            totalPrice: {\n                value: store.cart.totalPrice,\n                discountValue: 0,\n            },\n            address: {\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                address_string: store.user.address || undefined,\n            },\n        },\n    };\n}\n\nwindow.AssistantClient = window.AssistantClient || {};\n// eslint-disable-next-line no-underscore-dangle\nwindow.__inbox = window.__inbox || [];\n// eslint-disable-next-line no-underscore-dangle\nwindow.__outbox = window.__outbox || [];\n\n/**\n * Assistand SDK API implementation:\n */\nwindow.AssistantClient.onStart = function AssistantSdkOnStart() {\n    console.log('invoke onStart callback');\n};\n\nwindow.AssistantClient.onData = function AssistantSdkOnMessage(command: AssistantSdkCommand): void {\n    // eslint-disable-next-line no-underscore-dangle\n    window.__inbox.push(command);\n    console.log('server message', command);\n    store.onMessage(command);\n};\n\nwindow.AssistantClient.sendData = function AssistantSdkSendMessage(message: any): void {\n    // eslint-disable-next-line no-underscore-dangle\n    window.__outbox.push({ message, store: castFromStore(store) });\n\n    console.log('sendData', message);\n\n    if (window.AssistantHost && typeof window.AssistantHost.sendData === 'function') {\n        window.AssistantHost.sendData(JSON.stringify(message), null);\n    }\n};\n\nwindow.AssistantClient.onRequestState = function AssistantSdkOnRequestState(): void {\n    console.log('invoke request state callback');\n    const state = castFromStore(store);\n\n    if (window.AssistantHost && typeof window.AssistantHost.updateState === 'function') {\n        window.AssistantHost.updateState(JSON.stringify(state));\n    }\n};\n\nexport default store;\n","import { useObserver } from 'mobx-react-lite';\n\nimport { StoreType } from '../stores/types';\n\nlet store: StoreType | null = null;\n\nexport const setStore = (newStore: StoreType): void => {\n    store = newStore;\n};\n\ntype PropsType = Record<string, any>;\n\nconst connect = (selector: Function) => (\n    baseComponent: React.FC<StoreType & PropsType>,\n): React.FC<StoreType & PropsType> => {\n    /* eslint-disable */\n    const component = (ownProps: PropsType) => {\n        if (store === null) throw new Error('Please, use setStore before your ReactDOM.render call');\n        return useObserver(() => {\n            return baseComponent({ ...ownProps, ...selector(store, ownProps) });\n        });\n    };\n    /* eslint-enable */\n    component.displayName = baseComponent.name;\n    return component;\n};\n\nexport default connect;\nexport const getStore = (): StoreType | null => store;\n\nexport const connectToStore = (component: React.FC<StoreType & any>): React.FC<StoreType & any> =>\n    connect((storeData: StoreType): StoreType => storeData)(component);\n","import packageJSON from '../../package.json';\n\nconst PREFIX = packageJSON.cssPrefix;\n\ninterface ConfitionsInterface<T> {\n    T?: boolean;\n}\n\nexport default (blockName: string, delimeter = '__', modDelimeter = '_'): BemRenderer => {\n    function renderer(...elements: string[]): string {\n        if (!elements.length) {\n            return PREFIX + blockName;\n        }\n\n        return elements.map((element) => PREFIX + blockName + delimeter + element).join(' ');\n    }\n\n    renderer.elem = (element: string, mod: string, modVal?: string): string =>\n        PREFIX + blockName + delimeter + element + modDelimeter + mod + (modVal ? modDelimeter + modVal : '');\n\n    renderer.mod = (mod: string, modVal?: string): string =>\n        PREFIX + blockName + modDelimeter + mod + (modVal ? modDelimeter + modVal : '');\n\n    renderer.modify = (conditions: ConfitionsInterface<string> = {}, elem?: string): string => {\n        const elemToModify = elem ? blockName + delimeter + elem : blockName;\n\n        return [\n            PREFIX,\n            elemToModify,\n            ' ',\n            Object.entries(conditions)\n                .map(([mod, predicate]) => Boolean(predicate) && PREFIX + elemToModify + modDelimeter + mod)\n                .filter(Boolean)\n                .join(' '),\n        ].join('');\n    };\n\n    renderer.all = (...values: string[]): string => values.join(' ');\n\n    return renderer;\n};\n","import React from 'react';\nimport Bem from 'tools/bem';\n\nexport default (Component: React.FC<any>, componentName?: string) => (props?: any, context?: any) => (\n    <Component {...props} context={context} bem={Bem(componentName || Component.name)} />\n);\n","import React from 'react';\nimport { StoreType } from 'stores/types';\nimport withBem from 'hoc/withBem';\nimport { connectToStore } from 'tools/connect';\n\nimport './Header.scss';\n\ninterface HeaderProps extends BemProps, StoreType {\n    className?: string;\n    title: string;\n}\n\nconst Component: React.FC<HeaderProps> = ({ bem, ui, title, children, className }) => (\n    <div className={bem.all(bem(), className || '')}>\n        {ui.previous ? <span className={bem('back')} /> : ''}\n        <div className={bem('section')}>\n            <div className={bem('logo')} />\n            <div className={bem('title')}>{title}</div>\n        </div>\n        <div className={bem('section')}>{children}</div>\n    </div>\n);\n\nexport const Header = connectToStore(withBem(Component, 'Header'));\n","import React from 'react';\nimport { connectToStore } from 'tools/connect';\nimport { StoreType } from 'stores/types';\nimport withBem from 'hoc/withBem';\nimport { routes } from 'stores/ui';\n\nimport './HeaderAddress.scss';\n\ninterface HeaderAddressProps extends StoreType, BemProps {}\n\nconst Component: React.FC<HeaderAddressProps> = ({ user, ui, bem }) => (\n    <div className={bem()} tabIndex={0} onClick={() => ui.gotoPage(routes.ADDRESS_SIMPLE)}>\n        <div className={bem('icon')} />\n        <div className={bem('text')}>{user.address}</div>\n    </div>\n);\n\nexport const HeaderAddress = withBem(connectToStore(Component), 'HeaderAddress');\n","export const splitByThousands = (data: string) =>\n    data.split('').reduceRight((acc, item, index, arr) => {\n        const indexFromEnd = index - (arr.length - 1);\n\n        if (indexFromEnd % 3 === 0) {\n            acc = ` ${acc}`;\n        }\n\n        return item + acc;\n    }, '');\n\nexport const throttle = (callback: any, timeout: number) => {\n    let timeoutId = 0;\n\n    return () => {\n        if (timeoutId) {\n            return;\n        }\n\n        timeoutId = setTimeout(() => {\n            timeoutId = 0;\n            callback();\n        }, timeout);\n    };\n};\n","import React from 'react';\nimport { connectToStore } from 'tools/connect';\nimport { StoreType } from 'stores/types';\nimport withBem from 'hoc/withBem';\nimport { splitByThousands } from 'tools';\n\nimport './HeaderCart.scss';\n\ninterface HeaderCartProps extends StoreType, BemProps {}\n\nconst Component: React.FC<HeaderCartProps> = ({ cart, ui, bem }) => (\n    <div className={bem()} tabIndex={0} onClick={() => ui.goToCart()}>\n        <div className={bem('icon')}>{cart.count > 0 && <span className={bem('badge')}>{cart.count}</span>}</div>\n        <div className={bem('price')}>{splitByThousands(String(cart.totalPrice))} ₽</div>\n    </div>\n);\n\nexport const HeaderCart = withBem(connectToStore(Component), 'HeaderCart');\n","import React from 'react';\n\nexport function useFocusOnMount<T>() {\n    const ref = React.useRef<T>(null);\n\n    React.useLayoutEffect(() => {\n        if (ref.current instanceof HTMLElement) {\n            ref.current.focus();\n        }\n    }, []);\n\n    return ref;\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst contentMap = {\n    'sold-out': 'Раскупили',\n    'few-left': 'Осталось мало',\n    sale: 'Скидка',\n};\n\nconst backgroundMap = {\n    'sold-out': '#080808',\n    'few-left': '#F6650A',\n    sale: '#08A652',\n};\n\nconst StyledBadge = styled.div`\n    padding: 8px 16px;\n    font-weight: 500;\n    font-size: 24px;\n    line-height: 32px;\n    color: #fff;\n    border-radius: 16px;\n    background-color: ${(props: BadgeProps) => backgroundMap[props.type]};\n`;\n\ninterface BadgeProps extends React.HTMLAttributes<HTMLDivElement> {\n    type: 'sold-out' | 'few-left' | 'sale';\n}\n\nexport const Badge: React.FC<BadgeProps> = ({ type, children, ...props }) => (\n    <StyledBadge type={type} {...props}>\n        {contentMap[type]} {children}\n    </StyledBadge>\n);\n","import React from 'react';\nimport withBem from 'hoc/withBem';\nimport { Badge } from 'components/Badge/Badge';\nimport { ProductItemModel } from 'stores/product';\n\nimport './CatalogListItem.scss';\n\ninterface CatalogListItemProps extends ProductItemModel, BemProps {\n    mountRef?: React.RefObject<HTMLDivElement>;\n    index: number;\n    countInCart: number;\n    onClick: () => void;\n}\n\nconst Component: React.FC<CatalogListItemProps> = ({\n    bem,\n    imagesUrls,\n    countInCart,\n    name,\n    price,\n    index,\n    quantityLeft,\n    onClick,\n    mountRef,\n}) => {\n    const [selected, setSelected] = React.useState(false);\n    const isSoldOut = Number(quantityLeft) === 0;\n    const canAddMoreItems = countInCart < Number(quantityLeft);\n\n    let badgeType = '';\n\n    if (selected) {\n        badgeType = canAddMoreItems ? 'add' : 'disabled';\n    } else if (countInCart) {\n        badgeType = 'done';\n    }\n\n    return (\n        <div\n            tabIndex={isSoldOut ? -1 : 0}\n            className={bem.modify({ 'sold-out': isSoldOut })}\n            onBlur={() => setSelected(false)}\n            onFocus={() => setSelected(true)}\n            onClick={onClick}\n            ref={mountRef}\n        >\n            {isSoldOut ? <Badge className={bem('badge')} type=\"sold-out\" /> : ''}\n            <div className={bem('index-badge')}>{index}</div>\n            <div className={bem('thumb')} style={{ backgroundImage: `url(${imagesUrls[0]})` }} />\n            <div className={bem('description')}>\n                <div className={bem.modify({ [badgeType]: Boolean(badgeType) }, 'add-badge')} />\n                <div className={bem('description-name')}>{name}</div>\n                <div className={bem('price-container')}>\n                    <div className={bem('price')}>{Math.floor(Number(price) / 100)} ₽</div>\n                    {countInCart ? <div className={bem('count')}>×{countInCart}</div> : ''}\n                </div>\n            </div>\n        </div>\n    );\n};\n\nexport const CatalogListItem = withBem(Component, 'CatalogListItem');\n","import React from 'react';\nimport { connectToStore } from 'tools/connect';\nimport withBem from 'hoc/withBem';\nimport { StoreType } from 'stores/types';\nimport { ProductItemModel } from 'stores/product';\nimport { useFocusOnMount } from 'hooks';\n\nimport { CatalogListItem } from '../ListItem/CatalogListItem';\nimport './CatalogList.scss';\n\ninterface CatalogListProps extends StoreType, BemProps {}\n\nconst Component: React.FC<CatalogListProps> = ({ bem, products, cart }) => {\n    const mountFocusRef = useFocusOnMount<HTMLDivElement>();\n\n    return (\n        <div className={bem()}>\n            <div className={bem('container')}>\n                {products.items.map((item: ProductItemModel, index) => (\n                    <CatalogListItem\n                        {...item}\n                        mountRef={!index ? mountFocusRef : undefined}\n                        countInCart={cart.itemsMap[item.id] ? cart.itemsMap[item.id].count : 0}\n                        key={item.id}\n                        index={index + 1}\n                        onClick={() => cart.addToCart(item.id)}\n                    />\n                ))}\n            </div>\n        </div>\n    );\n};\n\nexport const CatalogList = withBem(connectToStore(Component), 'CatalogList');\n","import React from 'react';\nimport ContentLoader, { IContentLoaderProps } from 'react-content-loader';\n\ninterface SkeletonProps extends IContentLoaderProps {\n    itemWidth: number;\n    itemHeight: number;\n    borderRadius: number;\n    rowCount: number;\n    columnCount: number;\n    paddingBetweenColumns: number;\n    paddingBetweenRows: number;\n}\n\nexport const Skeleton: React.FC<SkeletonProps> = ({\n    itemWidth,\n    itemHeight,\n    borderRadius,\n    rowCount,\n    columnCount,\n    paddingBetweenColumns,\n    paddingBetweenRows,\n    ...props\n}) => {\n    const list = Array.from(Array(columnCount)).map((_, columnIndex) =>\n        Array.from(Array(rowCount)).map((_, rowIndex) => (\n            <rect\n                key={`${columnIndex} ${rowIndex}`}\n                x={columnIndex * (itemWidth + paddingBetweenColumns)}\n                y={rowIndex * (itemHeight + paddingBetweenRows)}\n                width={itemWidth}\n                height={itemHeight}\n                rx={borderRadius}\n                ry={borderRadius}\n            />\n        )),\n    );\n\n    return <ContentLoader {...props}>{list}</ContentLoader>;\n};\n","import React from 'react';\nimport { Skeleton } from 'components/Skeleton/Skeleton';\nimport withBem from 'hoc/withBem';\n\nimport './CatalogSkeleton.scss';\n\ntype CatalogSkeletonProps = BemProps;\n\nconst itemWidth = 392;\nconst itemHeight = 592;\nconst columnCount = 5;\nconst paddingBetween = 32;\n\nexport const Component: React.FC<CatalogSkeletonProps> = ({ bem }) => (\n    <div className={bem()}>\n        <Skeleton\n            viewBox={`0 0 ${itemWidth * columnCount + paddingBetween * (columnCount - 1)} ${itemHeight}`}\n            width=\"100%\"\n            height=\"100%\"\n            backgroundColor=\"#262828\"\n            foregroundColor=\"#414545\"\n            itemWidth={itemWidth}\n            itemHeight={itemHeight}\n            borderRadius={24}\n            rowCount={2}\n            columnCount={5}\n            paddingBetweenRows={paddingBetween}\n            paddingBetweenColumns={paddingBetween}\n            speed={2}\n        />\n    </div>\n);\n\nexport const CatalogSkeleton = withBem(Component, 'CatalogSkeleton');\n","import React from 'react';\nimport { SHOW_ITEMS_MOCK } from 'mocks';\nimport { Header } from 'components/Header/Header';\nimport { HeaderAddress } from 'components/HeaderAddress/HeaderAddress';\nimport { HeaderCart } from 'components/HeaderCart/HeaderCart';\nimport { connectToStore } from 'tools/connect';\nimport { StoreType } from 'stores/types';\n\nimport { CatalogList } from './List/CatalogList';\nimport { CatalogSkeleton } from './Skeleton/CatalogSkeleton';\n\ntype CatalogProps = StoreType;\n\nconst Component: React.FC<CatalogProps> = ({ cart, products }) => {\n    React.useEffect(() => {\n        window.AssistantClient.sendData({\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            action_id: 'ASK_FOR_STOCK',\n        });\n    }, []);\n\n    React.useEffect(() => {\n        if (process.env.REACT_APP_ENVIRONMENT === 'development') {\n            window.AssistantClient.onData({\n                type: 'smart_app_data',\n                // eslint-disable-next-line\n                smart_app_data: {\n                    command: 'SHOW_ITEMS',\n                    stock: SHOW_ITEMS_MOCK,\n                },\n            });\n\n            window.AssistantClient.onData({\n                type: 'smart_app_data',\n                // eslint-disable-next-line\n                smart_app_data: {\n                    command: 'ADD_ITEM',\n                    item: '21ff407a-fa98-11e8-80c5-0cc47a817925',\n                    count: '2',\n                },\n            });\n        }\n    }, []);\n\n    return (\n        <>\n            <Header title=\"Самокат\">\n                <HeaderAddress />\n                {cart.count > 0 ? <HeaderCart /> : ''}\n            </Header>\n            {products.items.length ? <CatalogList /> : <CatalogSkeleton />}\n        </>\n    );\n};\n\nexport const Catalog = connectToStore(Component);\n","import React from 'react';\nimport styled from 'styled-components';\nimport { useFocusOnMount } from 'hooks';\n\nconst StyledButton = styled.button`\n    padding: 20px 40px;\n    border-radius: 40px;\n    display: flex;\n    border: none;\n    color: #fff;\n    font-weight: 600;\n    font-size: 32px;\n    align-items: center;\n    justify-content: center;\n    background-color: rgba(255, 255, 255, 0.1);\n    transition: background-color 0.3s ease-in-out;\n\n    &:focus {\n        background-color: #08a652;\n    }\n\n    &[disabled] {\n        opacity: 0.5;\n    }\n`;\n\ninterface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n    shouldFocusOnMount?: boolean;\n}\n\nexport const Button: React.FC<ButtonProps> = ({ className, shouldFocusOnMount, ...props }) => {\n    const mountFocusRef = useFocusOnMount<HTMLButtonElement>();\n\n    return (\n        <StyledButton className={className} ref={shouldFocusOnMount ? mountFocusRef : null} type=\"button\" {...props} />\n    );\n};\n","import React from 'react';\nimport withBem from 'hoc/withBem';\nimport { connectToStore } from 'tools/connect';\nimport { Button } from 'components/Button/Button';\nimport { StoreType } from 'stores/types';\n\nimport './CartInfo.scss';\nimport { MINIMAL_PRICE } from '../Cart';\n\ninterface CartInfoProps extends BemProps, StoreType {}\n\nconst addAddressInfo = (user: StoreType['user']) =>\n    user.updateUser({\n        location: 'подъезд 1, корпус Г',\n        phoneNumber: '+7 910 345 67 89',\n        name: 'Сергей',\n    });\n\nconst Component: React.FC<CartInfoProps> = ({ bem, user, cart }) => {\n    const { phoneNumber, address, location, name } = user;\n    const hasPersonalData = phoneNumber && address && location && name;\n\n    return (\n        <div className={bem()}>\n            <div className={bem('badge')}>\n                <div className={bem('badge-body')}>\n                    <div className={bem('badge-name')}>15-30</div>\n                    <div className={bem('badge-desc')}>мин</div>\n                </div>\n                <div className={bem('badge-kernel')} />\n                <div className={bem.modify({ big: true }, 'badge-shadow')} />\n                <div className={bem.modify({ small: true }, 'badge-shadow')} />\n            </div>\n            <div className={bem('address')}>{user.address}</div>\n            {hasPersonalData ? (\n                <>\n                    <div className={bem('personal')}>\n                        <div className={bem('personal-location')}>{user.location}</div>\n                        <div className={bem('personal-phone-number')}>{user.phoneNumber}</div>\n                        <div className={bem('personal-name')}>{user.name}</div>\n                    </div>\n                    <Button\n                        className={bem.modify({ disabled: false }, 'button')}\n                        disabled={cart.totalPrice < MINIMAL_PRICE}\n                        shouldFocusOnMount\n                        onClick={() => cart.makePurchase()}\n                    >\n                        Перейти к оплате\n                    </Button>\n                </>\n            ) : (\n                <>\n                    <div className={bem('ask-personal')}>\n                        Чтобы сделать заказ, укажите квартиру, подъезд и другую дополнительную информацию\n                    </div>\n                    <Button\n                        className={bem.modify({ disabled: false }, 'button')}\n                        shouldFocusOnMount\n                        onClick={() => addAddressInfo(user)}\n                    >\n                        Дополнить адрес\n                    </Button>\n                </>\n            )}\n        </div>\n    );\n};\n\nexport const CartInfo = withBem(connectToStore(Component), 'CartInfo');\n","import React from 'react';\nimport { CartItemModel } from 'stores/cart';\nimport { Button } from 'components/Button/Button';\nimport withBem from 'hoc/withBem';\n\nimport './CartListItem.scss';\n\ninterface CartListItemProps extends CartItemModel, BemProps {\n    index: number;\n    onMoreClick: () => void;\n    onLessClick: (count: number, shouldRemoveMention?: boolean) => void;\n    onSelect: (index: number) => void;\n}\n\nconst Component: React.FC<CartListItemProps> = ({\n    index,\n    onLessClick,\n    onMoreClick,\n    onSelect,\n    product: { imagesUrls, clearName, price, quantityLeft },\n    count,\n    bem,\n}) => {\n    const [selected, setFocus] = React.useState(false);\n    const isSoldOut = Number(quantityLeft) === 0;\n    const canAddMore = count < Number(quantityLeft);\n    const memoizedOnFocus = React.useCallback(() => {\n        onSelect(index - 1); // -1 потому что индекс сдвинут на единицу вперед\n        setFocus(true);\n    }, [onSelect, index]);\n\n    return (\n        <div className={bem.modify({ 'sold-out': isSoldOut })}>\n            <div className={bem('index-badge')}>{index}</div>\n            <div className={bem('image')} style={{ backgroundImage: `url(\"${imagesUrls[0]}\")` }} />\n            <div className={bem('info')}>\n                <div className={bem.modify({ 'one-line': isSoldOut }, 'name')}>{clearName}</div>\n                <div className={bem('price')}>{Math.floor(Number(price) / 100)} ₽</div>\n                {isSoldOut ? <div className={bem('sold-out')}>Раскупили</div> : ''}\n            </div>\n            {isSoldOut ? (\n                <Button className={bem('remove-button')} onClick={() => onLessClick(count, true)}>\n                    Удалить\n                </Button>\n            ) : (\n                <div className={bem.modify({ selected }, 'selector')}>\n                    <button\n                        type=\"button\"\n                        aria-label=\"less\"\n                        className={bem.modify({ less: !!count, remove: !count }, 'selector-button')}\n                        onFocus={memoizedOnFocus}\n                        onBlur={() => setFocus(false)}\n                        onClick={() => onLessClick(1, !count)}\n                    />\n                    <div className={bem('selector-value')}>{count}</div>\n                    <button\n                        type=\"button\"\n                        aria-label=\"more\"\n                        disabled={!canAddMore}\n                        className={bem.modify({ more: true }, 'selector-button')}\n                        onFocus={memoizedOnFocus}\n                        onBlur={() => setFocus(false)}\n                        onClick={onMoreClick}\n                    />\n                </div>\n            )}\n        </div>\n    );\n};\n\nexport const CartListItem = withBem(Component, 'CartListItem');\n","import React from 'react';\nimport { connectToStore } from 'tools/connect';\nimport { splitByThousands } from 'tools';\nimport { StoreType } from 'stores/types';\nimport { SHOW_ITEMS_MOCK } from 'mocks';\nimport withBem from 'hoc/withBem';\n\nimport { CartListItem } from '../ListItem/CartListItem';\nimport { MINIMAL_PRICE } from '../Cart';\n\nimport './CartList.scss';\n\ninterface CartListProps extends StoreType, BemProps {}\n\nconst ITEM_WIDTH = 152;\n\nconst onScroll = (e: React.UIEvent<HTMLDivElement>) => {\n    e.currentTarget.scrollTop = 0;\n};\n\nconst getOffset = (index: number, itemsCount: number) => {\n    // так как индекс начинается с 0, то расчеты бы имели смысл начиная\n    // со второго элемента (индекс = 1), но нам нужно начинать скролл с\n    // 3-го элемента, поэтому сдвигаем значение на 1\n    let relatedIndex = Math.max(0, index - 1);\n\n    // ограничиваем максимальное значение индекса\n    relatedIndex = Math.min(Math.max(0, itemsCount - 4), relatedIndex);\n\n    // домножаем отступ на коэффициент высоты айтема\n    return relatedIndex * ITEM_WIDTH;\n};\n\nconst Component: React.FC<CartListProps> = ({ cart, bem }) => {\n    const { items } = cart;\n    const [selectedItemIndex, setSelectedItemIndex] = React.useState(0);\n    const isFirstItemSelected = !selectedItemIndex;\n    const isLastItemSelected = selectedItemIndex === items.length - 1;\n\n    const wrapperStyle: React.CSSProperties = {\n        transform: `translateY(-${getOffset(selectedItemIndex, items.length)}px)`,\n    };\n\n    React.useEffect(() => {\n        if (process.env.REACT_APP_ENVIRONMENT === 'development') {\n            const stock = {\n                ...SHOW_ITEMS_MOCK,\n                ...Object.values(SHOW_ITEMS_MOCK).reduce((acc, item) => {\n                    const guid = item.guid + Math.random() * 1000;\n\n                    return {\n                        ...acc,\n                        [guid]: {\n                            ...item,\n                            guid,\n                        },\n                    };\n                }, {}),\n            };\n\n            window.AssistantClient.onData({\n                type: 'smart_app_data',\n                // eslint-disable-next-line\n                smart_app_data: {\n                    command: 'SHOW_ITEMS',\n                    stock,\n                },\n            });\n\n            Object.values(stock).map((item) =>\n                window.AssistantClient.onData({\n                    type: 'smart_app_data',\n                    // eslint-disable-next-line\n                    smart_app_data: {\n                        command: 'ADD_ITEM',\n                        item: item.guid,\n                        count: Math.floor(Math.random() * 5),\n                    },\n                }),\n            );\n        }\n    }, []);\n\n    return (\n        <div className={bem()}>\n            <div className={bem('container')} onScroll={onScroll}>\n                <div\n                    className={bem.modify({ top: true, hidden: items.length <= 4 || isFirstItemSelected }, 'gradient')}\n                />\n                <div className={bem('wrapper')} style={wrapperStyle}>\n                    {items.map((item, index) => (\n                        <CartListItem\n                            {...item}\n                            onSelect={setSelectedItemIndex}\n                            onLessClick={(count: number, shouldRemoveMention: boolean) =>\n                                cart.removeFromCart({\n                                    itemId: item.product.id,\n                                    count,\n                                    shouldRemoveMention,\n                                })\n                            }\n                            onMoreClick={() => cart.addToCart(item.product.id)}\n                            index={index + 1}\n                            key={item.product.id}\n                        />\n                    ))}\n                </div>\n                <div\n                    className={bem.modify(\n                        { bottom: true, hidden: items.length <= 4 || isLastItemSelected },\n                        'gradient',\n                    )}\n                />\n            </div>\n            <div className={bem('total-price')}>Сумма заказа {splitByThousands(String(cart.totalPrice))} ₽</div>\n            {cart.totalPrice < MINIMAL_PRICE ? (\n                <div className={bem('minimal-price')}>\n                    До минимального заказа еще {Math.ceil(MINIMAL_PRICE - cart.totalPrice)} ₽\n                </div>\n            ) : (\n                ''\n            )}\n        </div>\n    );\n};\n\nexport const CartList = withBem(connectToStore(Component), 'CartList');\n","import React from 'react';\nimport { Header } from 'components/Header/Header';\nimport { connectToStore } from 'tools/connect';\nimport { StoreType } from 'stores/types';\nimport withBem from 'hoc/withBem';\n\nimport { CartInfo } from './Info/CartInfo';\nimport { CartList } from './List/CartList';\nimport './Cart.scss';\n\nexport const MINIMAL_PRICE = 200;\n\ninterface CartProps extends StoreType, BemProps {}\n\nconst Component: React.FC<CartProps> = ({ bem }) => (\n    <>\n        <div className={bem('background')} />\n        <Header title=\"Корзина\" />\n        <div className={bem('container')}>\n            <CartList />\n            <CartInfo />\n        </div>\n    </>\n);\n\nexport const Cart = withBem(connectToStore(Component), 'Cart');\n","import React from 'react';\nimport styled from 'styled-components';\nimport { Header } from 'components/Header/Header';\nimport { Button } from 'components/Button/Button';\nimport { StoreType } from 'stores/types';\nimport { connectToStore } from 'tools/connect';\n\nimport FirstFigureIcon from './figure-1.svg';\nimport SecondFigureIcon from './figure-2.svg';\nimport ThirdFigureIcon from './figure-3.svg';\nimport FourthFigureIcon from './figure-4.svg';\nimport SixthFigureIcon from './figure-6.svg';\nimport SeventhFigureIcon from './figure-7.svg';\nimport EighthFigureIcon from './figure-8.svg';\nimport NinthFigureIcon from './figure-9.svg';\n\nconst StatusButton = styled(Button)`\n    margin-top: 60px;\n`;\n\nconst StatusContainer = styled.div`\n    position: relative;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 206px 0 0;\n`;\n\nconst StatusOrderNumber = styled.div`\n    font-size: 32px;\n    font-weight: 600;\n    line-height: 44px;\n    color: rgba(255, 255, 255, 0.74);\n`;\n\nconst StatusOrderTime = styled.div`\n    margin-top: 16px;\n    font-weight: bold;\n    font-size: 64px;\n    line-height: 72px;\n    text-align: center;\n    color: #fff;\n`;\n\nconst StatusFigure = styled.div`\n    background-repeat: no-repeat;\n    background-position: center;\n    background-size: contain;\n`;\n\nconst StatusFirstFigure = styled(StatusFigure)`\n    position: absolute;\n    top: 92px;\n    left: 834px;\n\n    height: 61px;\n    width: 61px;\n\n    background-image: url('${FirstFigureIcon}');\n`;\n\nconst StatusSecondFigure = styled(StatusFigure)`\n    position: absolute;\n    top: 0;\n    left: 482px;\n\n    height: 61px;\n    width: 61px;\n\n    background-image: url('${SecondFigureIcon}');\n`;\n\nconst StatusThirdFigure = styled(StatusFigure)`\n    position: absolute;\n    top: 280px;\n    left: 236px;\n\n    height: 46px;\n    width: 46px;\n\n    background-image: url('${ThirdFigureIcon}');\n`;\n\nconst StatusFourthFigure = styled(StatusFigure)`\n    position: absolute;\n    top: 158px;\n    left: 1487px;\n\n    height: 53px;\n    width: 53px;\n\n    background-image: url('${FourthFigureIcon}');\n`;\n\nconst StatusFifthFigure = styled(StatusFigure)`\n    position: absolute;\n    top: 594px;\n    left: 340px;\n\n    height: 53px;\n    width: 53px;\n\n    transform: rotate(90deg);\n\n    background-image: url('${FirstFigureIcon}');\n`;\n\nconst StatusSixthFigure = styled(StatusFigure)`\n    position: absolute;\n    top: 500px;\n    left: 652px;\n\n    height: 60px;\n    width: 60px;\n\n    background-image: url('${SixthFigureIcon}');\n`;\n\nconst StatusSeventhFigure = styled(StatusFigure)`\n    position: absolute;\n    top: 705px;\n    left: 1044px;\n\n    height: 40px;\n    width: 40px;\n\n    background-image: url('${SeventhFigureIcon}');\n`;\n\nconst StatusEighthFigure = styled(StatusFigure)`\n    position: absolute;\n    top: 492px;\n    left: 1268px;\n\n    height: 40px;\n    width: 40px;\n\n    background-image: url('${EighthFigureIcon}');\n`;\n\nconst StatusNinthFigure = styled(StatusFigure)`\n    position: absolute;\n    top: 590px;\n    left: 1604px;\n\n    height: 90px;\n    width: 90px;\n\n    background-image: url('${NinthFigureIcon}');\n`;\n\ntype StatusProps = StoreType;\n\nconst Component: React.FC<StatusProps> = ({ cart }) => (\n    <>\n        <Header title=\"Самокат\" />\n        <StatusContainer>\n            <StatusOrderNumber>Заказ #{cart.orderId} оформлен</StatusOrderNumber>\n            <StatusOrderTime>\n                Спасибо за заказ!\n                <br />\n                Будем у вас через 15-30 минут.\n            </StatusOrderTime>\n            <StatusButton shouldFocusOnMount>Очень жду</StatusButton>\n            <StatusFirstFigure />\n            <StatusSecondFigure />\n            <StatusThirdFigure />\n            <StatusFourthFigure />\n            <StatusFifthFigure />\n            <StatusSixthFigure />\n            <StatusSeventhFigure />\n            <StatusEighthFigure />\n            <StatusNinthFigure />\n        </StatusContainer>\n    </>\n);\n\nexport const Status = connectToStore(Component);\n","import React from 'react';\nimport withBem from 'hoc/withBem';\nimport { useFocusOnMount, useInterval } from 'hooks';\nimport { Button } from 'components/Button/Button';\n\nimport './Promo.scss';\n\ntype PromoProps = BemProps;\n\nconst POPCORN_TYPES_COUNT = 4;\n\nconst Component: React.FC<PromoProps> = ({ bem }) => {\n    const mountRef = useFocusOnMount<HTMLButtonElement>();\n    const [currentIndex, setIndex] = React.useState(0);\n    useInterval(() => setIndex(currentIndex === POPCORN_TYPES_COUNT - 1 ? 0 : currentIndex + 1), 3000);\n\n    return (\n        <div className={bem.modify({ [`type-${currentIndex + 1}`]: true })}>\n            <div className={bem('glow')}>\n                <div className={bem.modify({ [`type-${currentIndex + 1}`]: true }, 'glow-1')} />\n                <div className={bem.modify({ [`type-${currentIndex + 1}`]: true }, 'glow-2')} />\n                <div className={bem.modify({ [`type-${currentIndex + 1}`]: true }, 'glow-3')} />\n                <div className={bem.modify({ [`type-${currentIndex + 1}`]: true }, 'glow-4')} />\n            </div>\n            <div className={bem('title')}>\n                Попкорн и напитки\n                <br />к просмотру фильмов\n                <br />и сериалов\n            </div>\n            <div className={bem('subtitle')}>\n                Доставим бесплатно в течении 15-30 минут для Москвы и Санкт-Петербурга\n            </div>\n            {Array.from(Array(POPCORN_TYPES_COUNT)).map((_, index) => (\n                <div\n                    key={index}\n                    className={bem.modify({ [`type-${index + 1}`]: true, hidden: index !== currentIndex }, 'image')}\n                />\n            ))}\n            <div className={bem('button-container')}>\n                <Button className={bem('button')} shouldFocusOnMount>\n                    Указать адрес\n                </Button>\n                <Button className={bem('button')}>Не сейчас</Button>\n            </div>\n        </div>\n    );\n};\n\nexport const Promo = withBem(Component, 'Promo');\n","import React from 'react';\n\nexport const useInterval = (callback: (...args: any[]) => void, timeout: number) =>\n    React.useEffect(() => {\n        const intervalId = setInterval(callback, timeout);\n\n        return () => clearInterval(intervalId);\n    });\n","import React from 'react';\nimport { Header } from 'components/Header/Header';\nimport { Button } from 'components/Button/Button';\nimport withBem from 'hoc/withBem';\nimport { connectToStore } from 'tools/connect';\nimport { StoreType } from 'stores/types';\n\nimport './NoArea.scss';\n\ninterface NoAreaProps extends BemProps, StoreType {}\n\nconst Component: React.FC<NoAreaProps> = ({ bem, user }) => (\n    <div className={bem()}>\n        <Header className={bem('header')} title=\"Адрес доставки\" />\n        <div className={bem('container')}>\n            <div className={bem('badge')}>\n                <div className={bem('badge-body')} />\n                <div className={bem('badge-kernel')} />\n                <div className={bem.modify({ big: true }, 'badge-shadow')} />\n                <div className={bem.modify({ small: true }, 'badge-shadow')} />\n            </div>\n            <div className={bem('title')}>{user.address}</div>\n            <div className={bem('subtitle')}>К сожалению, пока не доставляем по этому адресу</div>\n            <Button shouldFocusOnMount className={bem('button')}>\n                Изменить\n            </Button>\n        </div>\n        <div className={bem('background')} />\n    </div>\n);\n\nexport const NoArea = withBem(connectToStore(Component), 'NoArea');\n","import React from 'react';\nimport withBem from 'hoc/withBem';\n\nimport './ScreenSaver.scss';\n\ntype ScreenSaverProps = BemProps;\n\nconst Component: React.FC<ScreenSaverProps> = ({ bem }) => (\n    <div className={bem()}>\n        Это скринсейвер\n        <br />\n        Здесь будет роскошный прелоадер с попкорном\n    </div>\n);\n\nexport const ScreenSaver = withBem(Component, 'ScreenSaver');\n","import React from 'react';\nimport { Header } from 'components/Header/Header';\nimport withBem from 'hoc/withBem';\n\nimport './AddressSimple.scss';\n\ntype AddressSimpleProps = BemProps;\n\nexport const Component: React.FC<AddressSimpleProps> = ({ bem }) => (\n    <>\n        <Header title=\"Адрес доставки\" />\n        <div className={bem('container')}>\n            <input type=\"text\" />\n        </div>\n    </>\n);\n\nexport const AddressSimple = withBem(Component, 'AddressSimple');\n","import React from 'react';\nimport { Redirect, Route, Switch } from 'react-router-dom';\nimport { Catalog } from 'pages/Catalog/Catalog';\nimport { Cart } from 'pages/Cart/Cart';\nimport { Status } from 'pages/Status/Status';\nimport { Promo } from 'pages/Promo/Promo';\nimport { NoArea } from 'pages/NoArea/NoArea';\nimport { ScreenSaver } from 'pages/ScreenSaver/ScreenSaver';\nimport { AddressSimple } from 'pages/AddressSimple/AddressSimple';\nimport withBem from 'hoc/withBem';\nimport { routes } from 'stores/ui';\nimport 'style/global.scss';\nimport 'normalize.css/normalize.css';\n\nimport './Root.scss';\n\ntype RootProps = BemProps;\n\nconst Component: React.FC<RootProps> = ({ bem }) => {\n    // эти костыли со стилями нужны для того, чтобы верстка норм смотрелась на планшете\n    // там разрешение экрана ~600X300 px\n    let containerStyle = {};\n    let wrapperStyle = {};\n\n    if (process.env.REACT_APP_ENVIRONMENT === 'staging') {\n        containerStyle = {\n            transform: 'scale(0.4)',\n            height: '1080px',\n            width: '1920px',\n        };\n\n        wrapperStyle = {\n            transform: 'translate(-580px, -310px)',\n        };\n    }\n\n    return (\n        <div style={wrapperStyle}>\n            <div style={containerStyle} className={bem()}>\n                <Switch>\n                    <Route path={routes.CATALOG}>\n                        <Catalog />\n                    </Route>\n                    <Route path={routes.CART}>\n                        <Cart />\n                    </Route>\n                    <Route path={routes.STATUS}>\n                        <Status />\n                    </Route>\n                    <Route path={routes.ADDRESS_SIMPLE}>\n                        <AddressSimple />\n                    </Route>\n                    <Route path={routes.PROMO}>\n                        <Promo />\n                    </Route>\n                    <Route path={routes.NO_AREA}>\n                        <NoArea />\n                    </Route>\n                    <Route path={routes.SCREEN_SAVER}>\n                        <ScreenSaver />\n                    </Route>\n                    <Redirect to={routes.SCREEN_SAVER} />\n                </Switch>\n            </div>\n        </div>\n    );\n};\n\nexport const Root = withBem(Component, 'Root');\n","/* eslint-disable */\n\n/* Spatial Navigation Polyfill\n *\n * It follows W3C official specification\n * https://drafts.csswg.org/css-nav-1/\n *\n * Copyright (c) 2018-2019 LG Electronics Inc.\n * https://github.com/WICG/spatial-navigation/polyfill\n *\n * Licensed under the MIT license (MIT)\n */\n\n(function () {\n    // The polyfill must not be executed, if it's already enabled via browser engine or browser extensions.\n    if ('navigate' in window) {\n        return;\n    }\n\n    const ARROW_KEY_CODE = { 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n    const TAB_KEY_CODE = 9;\n    let mapOfBoundRect = null;\n    let startingPoint = null; // Saves spatial navigation starting point\n    let savedSearchOrigin = { element: null, rect: null }; // Saves previous search origin\n    let searchOriginRect = null; // Rect of current search origin\n\n    window.__getSpatNavState = () => {\n        return {\n            mapOfBoundRect,\n            startingPoint,\n            savedSearchOrigin,\n            searchOriginRect,\n        };\n    };\n\n    /**\n     * Initiate the spatial navigation features of the polyfill.\n     * @function initiateSpatialNavigation\n     */\n    function initiateSpatialNavigation() {\n        /*\n         * Bind the standards APIs to be exposed to the window object for authors\n         */\n        window.navigate = navigate;\n        window.Element.prototype.spatialNavigationSearch = spatialNavigationSearch;\n        window.Element.prototype.focusableAreas = focusableAreas;\n        window.Element.prototype.getSpatialNavigationContainer = getSpatialNavigationContainer;\n\n        /*\n         * CSS.registerProperty() from the Properties and Values API\n         * Reference: https://drafts.css-houdini.org/css-properties-values-api/#the-registerproperty-function\n         */\n        if (window.CSS && CSS.registerProperty) {\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-contain') ===\n                ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-contain',\n                    syntax: 'auto | contain',\n                    inherits: false,\n                    initialValue: 'auto',\n                });\n            }\n\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-action') === ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-action',\n                    syntax: 'auto | focus | scroll',\n                    inherits: false,\n                    initialValue: 'auto',\n                });\n            }\n\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-function') ===\n                ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-function',\n                    syntax: 'normal | grid',\n                    inherits: false,\n                    initialValue: 'normal',\n                });\n            }\n        }\n    }\n\n    /**\n     * Add event handlers for the spatial navigation behavior.\n     * This function defines which input methods trigger the spatial navigation behavior.\n     * @function spatialNavigationHandler\n     */\n    function spatialNavigationHandler() {\n        /*\n         * keydown EventListener :\n         * If arrow key pressed, get the next focusing element and send it to focusing controller\n         */\n        window.addEventListener('keydown', (e) => {\n            const currentKeyMode =\n                (parent && parent.__spatialNavigation__.keyMode) || window.__spatialNavigation__.keyMode;\n            const eventTarget = document.activeElement;\n            const dir = ARROW_KEY_CODE[e.keyCode];\n\n            if (e.keyCode === TAB_KEY_CODE) {\n                startingPoint = null;\n            }\n\n            if (\n                !currentKeyMode ||\n                currentKeyMode === 'NONE' ||\n                (currentKeyMode === 'SHIFTARROW' && !e.shiftKey) ||\n                (currentKeyMode === 'ARROW' && e.shiftKey) ||\n                e.ctrlKey ||\n                e.metaKey ||\n                e.altKey\n            )\n                return;\n\n            if (!e.defaultPrevented) {\n                let focusNavigableArrowKey = {\n                    left: true,\n                    up: true,\n                    right: true,\n                    down: true,\n                };\n\n                // Edge case (text input, area) : Don't move focus, just navigate cursor in text area\n                if (eventTarget.nodeName === 'INPUT' || eventTarget.nodeName === 'TEXTAREA') {\n                    focusNavigableArrowKey = handlingEditableElement(e);\n                }\n\n                if (focusNavigableArrowKey[dir]) {\n                    e.preventDefault();\n                    mapOfBoundRect = new Map();\n\n                    navigate(dir);\n\n                    mapOfBoundRect = null;\n                    startingPoint = null;\n                }\n            }\n        });\n\n        /*\n         * mouseup EventListener :\n         * If the mouse click a point in the page, the point will be the starting point.\n         * NOTE: Let UA set the spatial navigation starting point based on click\n         */\n        document.addEventListener('mouseup', (e) => {\n            startingPoint = { x: e.clientX, y: e.clientY };\n        });\n\n        /*\n         * focusin EventListener :\n         * When the element get the focus, save it and its DOMRect for resetting the search origin\n         * if it disappears.\n         */\n        window.addEventListener('focusin', (e) => {\n            if (e.target !== window) {\n                savedSearchOrigin.element = e.target;\n                savedSearchOrigin.rect = e.target.getBoundingClientRect();\n            }\n        });\n    }\n\n    /**\n     * Enable the author to trigger spatial navigation programmatically, as if the user had done so manually.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-window-navigate}\n     * @function navigate\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function navigate(dir) {\n        // spatial navigation steps\n\n        // 1\n        const searchOrigin = findSearchOrigin();\n        console.log(searchOrigin);\n        let eventTarget = searchOrigin;\n        let elementFromPosition = null;\n\n        // 2 Optional step, UA defined starting point\n        if (startingPoint) {\n            // if there is a starting point, set eventTarget as the element from position for getting the spatnav container\n            elementFromPosition = document.elementFromPoint(startingPoint.x, startingPoint.y);\n\n            // Use starting point if the starting point isn't inside the focusable element (but not container)\n            // * Starting point is meaningfull when:\n            // 1) starting point is inside the spatnav container\n            // 2) starting point is inside the non-focusable element\n            if (elementFromPosition === null) {\n                elementFromPosition = document.body;\n            }\n            if (isFocusable(elementFromPosition) && !isContainer(elementFromPosition)) {\n                startingPoint = null;\n            } else if (isContainer(elementFromPosition)) {\n                eventTarget = elementFromPosition;\n            } else {\n                eventTarget = elementFromPosition.getSpatialNavigationContainer();\n            }\n        }\n\n        // 4\n        if (eventTarget === window || eventTarget === document || eventTarget === document.documentElement) {\n            eventTarget = document.body || document.documentElement;\n        }\n\n        // 5\n        // At this point, spatialNavigationSearch can be applied.\n        // If startingPoint is either a scroll container or the document,\n        // find the best candidate within startingPoint\n        let container = null;\n        if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {\n            if (eventTarget.nodeName === 'IFRAME') {\n                eventTarget = eventTarget.contentDocument.documentElement;\n            }\n\n            container = container === window ? document.body : eventTarget;\n            let bestInsideCandidate = null;\n\n            // 5-2\n            if (\n                document.activeElement === searchOrigin ||\n                (document.activeElement === document.body && searchOrigin === document.documentElement)\n            ) {\n                if (getCSSSpatNavAction(eventTarget) === 'scroll') {\n                    if (scrollingController(eventTarget, dir)) return;\n                } else if (getCSSSpatNavAction(eventTarget) === 'focus') {\n                    bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, {\n                        container: eventTarget,\n                        candidates: getSpatialNavigationCandidates(eventTarget, {\n                            mode: 'all',\n                        }),\n                    });\n                    if (focusingController(bestInsideCandidate, dir)) return;\n                } else if (getCSSSpatNavAction(eventTarget) === 'auto') {\n                    bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, {\n                        container: eventTarget,\n                    });\n                    if (focusingController(bestInsideCandidate, dir) || scrollingController(eventTarget, dir)) return;\n                }\n            } else {\n                // when the previous search origin became offscreen\n                container = container.getSpatialNavigationContainer();\n            }\n        }\n\n        // 6\n        // Let container be the nearest ancestor of eventTarget\n        container = eventTarget.getSpatialNavigationContainer();\n        let parentContainer = container.parentElement ? container.getSpatialNavigationContainer() : null;\n\n        // When the container is the viewport of a browsing context\n        if (!parentContainer && window.location !== window.parent.location) {\n            parentContainer = window.parent.document.documentElement;\n        }\n\n        if (getCSSSpatNavAction(container) === 'scroll') {\n            if (scrollingController(container, dir)) return;\n        } else if (getCSSSpatNavAction(container) === 'focus') {\n            navigateChain(eventTarget, container, parentContainer, dir, 'all');\n        } else if (getCSSSpatNavAction(container) === 'auto') {\n            navigateChain(eventTarget, container, parentContainer, dir, 'visible');\n        }\n    }\n\n    /**\n     * Move the focus to the best candidate or do nothing.\n     * @function focusingController\n     * @param bestCandidate {Node} - The best candidate of the spatial navigation\n     * @param dir {SpatialNavigationDirection}- The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function focusingController(bestCandidate, dir) {\n        // 10 & 11\n        // When bestCandidate is found\n        if (bestCandidate) {\n            // When bestCandidate is a focusable element and not a container : move focus\n            /*\n             * [event] navbeforefocus : Fired before spatial or sequential navigation changes the focus.\n             */\n            if (!createSpatNavEvents('beforefocus', bestCandidate, null, dir)) return true;\n\n            const container = bestCandidate.getSpatialNavigationContainer();\n\n            if (container !== window && getCSSSpatNavAction(container) === 'focus') {\n                bestCandidate.focus();\n            } else {\n                bestCandidate.focus({ preventScroll: true });\n            }\n\n            startingPoint = null;\n            return true;\n        }\n\n        // When bestCandidate is not found within the scrollport of a container: Nothing\n        return false;\n    }\n\n    /**\n     * Directionally scroll the scrollable spatial navigation container if it can be manually scrolled more.\n     * @function scrollingController\n     * @param container {Node} - The spatial navigation container which can scroll\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function scrollingController(container, dir) {\n        // If there is any scrollable area among parent elements and it can be manually scrolled, scroll the document\n        if (isScrollable(container, dir) && !isScrollBoundary(container, dir)) {\n            moveScroll(container, dir);\n            return true;\n        }\n\n        // If the spatnav container is document and it can be scrolled, scroll the document\n        if (!container.parentElement && !isHTMLScrollBoundary(container, dir)) {\n            moveScroll(container.ownerDocument.documentElement, dir);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Find the candidates within a spatial navigation container include delegable container.\n     * This function does not search inside delegable container or focusable container.\n     * In other words, this return candidates set is not included focusable elements inside delegable container or focusable container.\n     *\n     * @function getSpatialNavigationCandidates\n     * @param container {Node} - The spatial navigation container\n     * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.\n     *                                          Default value is 'visible'.\n     * @returns {sequence<Node>} candidate elements within the container\n     */\n    function getSpatialNavigationCandidates(container, option = { mode: 'visible' }) {\n        let candidates = [];\n\n        if (container.childElementCount > 0) {\n            if (!container.parentElement) {\n                container = container.getElementsByTagName('body')[0] || document.body;\n            }\n            const children = container.children;\n            for (const elem of children) {\n                if (isDelegableContainer(elem)) {\n                    candidates.push(elem);\n                } else if (isFocusable(elem)) {\n                    candidates.push(elem);\n\n                    if (!isContainer(elem) && elem.childElementCount) {\n                        candidates = candidates.concat(getSpatialNavigationCandidates(elem, { mode: 'all' }));\n                    }\n                } else if (elem.childElementCount) {\n                    candidates = candidates.concat(getSpatialNavigationCandidates(elem, { mode: 'all' }));\n                }\n            }\n        }\n\n        //   console.log(candidates)\n        return option.mode === 'all' ? candidates : candidates.filter(isVisible);\n    }\n\n    /**\n     * Find the candidates among focusable elements within a spatial navigation container from the search origin (currently focused element)\n     * depending on the directional information.\n     * @function getFilteredSpatialNavigationCandidates\n     * @param element {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation without the directional information\n     * @param container {Node} - The spatial navigation container\n     * @returns {Node} The candidates for spatial navigation considering the directional information\n     */\n    function getFilteredSpatialNavigationCandidates(element, dir, candidates, container) {\n        const targetElement = element;\n        // Removed below line due to a bug. (iframe body rect is sometime weird.)\n        // const targetElement = (element.nodeName === 'IFRAME') ? element.contentDocument.body : element;\n        // If the container is unknown, get the closest container from the element\n        container = container || targetElement.getSpatialNavigationContainer();\n\n        // If the candidates is unknown, find candidates\n        // 5-1\n        candidates = !candidates || candidates.length <= 0 ? getSpatialNavigationCandidates(container) : candidates;\n        return filteredCandidates(targetElement, candidates, dir, container);\n    }\n\n    /**\n     * Find the best candidate among the candidates within the container from the search origin (currently focused element)\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-spatialnavigationsearch}\n     * @function spatialNavigationSearch\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param container {Node} - The spatial navigation container\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function spatialNavigationSearch(dir, args) {\n        const targetElement = this;\n        let internalCandidates = [];\n        let externalCandidates = [];\n        let insideOverlappedCandidates = getOverlappedCandidates(targetElement);\n        let bestTarget;\n\n        // Set default parameter value\n        if (!args) args = {};\n\n        const defaultContainer = targetElement.getSpatialNavigationContainer();\n        let defaultCandidates = getSpatialNavigationCandidates(defaultContainer);\n        const container = args.container || defaultContainer;\n        if (args.container && defaultContainer.contains(args.container)) {\n            defaultCandidates = defaultCandidates.concat(getSpatialNavigationCandidates(container));\n        }\n        const candidates =\n            args.candidates && args.candidates.length > 0\n                ? args.candidates.filter((candidate) => container.contains(candidate))\n                : defaultCandidates.filter((candidate) => container.contains(candidate) && container !== candidate);\n\n        // Find the best candidate\n        // 5\n        // If startingPoint is either a scroll container or the document,\n        // find the best candidate within startingPoint\n        if (candidates && candidates.length > 0) {\n            // Divide internal or external candidates\n            candidates.forEach((candidate) => {\n                if (candidate !== targetElement) {\n                    (targetElement.contains(candidate) && targetElement !== candidate\n                            ? internalCandidates\n                            : externalCandidates\n                    ).push(candidate);\n                }\n            });\n\n            // include overlapped element to the internalCandidates\n            let fullyOverlapped = insideOverlappedCandidates.filter(\n                (candidate) => !internalCandidates.includes(candidate),\n            );\n            let overlappedContainer = candidates.filter(\n                (candidate) => isContainer(candidate) && isEntirelyVisible(targetElement, candidate),\n            );\n            let overlappedByParent = overlappedContainer\n                .map((elm) => elm.focusableAreas())\n                .flat()\n                .filter((candidate) => candidate !== targetElement);\n\n            internalCandidates = internalCandidates\n                .concat(fullyOverlapped)\n                .filter((candidate) => container.contains(candidate));\n            externalCandidates = externalCandidates\n                .concat(overlappedByParent)\n                .filter((candidate) => container.contains(candidate));\n\n            // Filter external Candidates\n            if (externalCandidates.length > 0) {\n                externalCandidates = getFilteredSpatialNavigationCandidates(\n                    targetElement,\n                    dir,\n                    externalCandidates,\n                    container,\n                );\n            }\n\n            // If there isn't search origin element but search orgin rect exist  (search origin isn't in the layout case)\n            if (searchOriginRect) {\n                bestTarget = selectBestCandidate(\n                    targetElement,\n                    getFilteredSpatialNavigationCandidates(targetElement, dir, internalCandidates, container),\n                    dir,\n                );\n            }\n\n            if (internalCandidates && internalCandidates.length > 0 && !(targetElement.nodeName === 'INPUT')) {\n                bestTarget = selectBestCandidateFromEdge(targetElement, internalCandidates, dir);\n            }\n\n            bestTarget = bestTarget || selectBestCandidate(targetElement, externalCandidates, dir);\n\n            if (bestTarget && isDelegableContainer(bestTarget)) {\n                // if best target is delegable container, then find descendants candidate inside delegable container.\n                const innerTarget = getSpatialNavigationCandidates(bestTarget, {\n                    mode: 'all',\n                });\n                const descendantsBest =\n                    innerTarget.length > 0\n                        ? targetElement.spatialNavigationSearch(dir, {\n                            candidates: innerTarget,\n                            container: bestTarget,\n                        })\n                        : null;\n                if (descendantsBest) {\n                    bestTarget = descendantsBest;\n                } else if (!isFocusable(bestTarget)) {\n                    // if there is no target inside bestTarget and delegable container is not focusable,\n                    // then try to find another best target without curren best target.\n                    candidates.splice(candidates.indexOf(bestTarget), 1);\n                    bestTarget = candidates.length\n                        ? targetElement.spatialNavigationSearch(dir, {\n                            candidates: candidates,\n                            container: container,\n                        })\n                        : null;\n                }\n            }\n            return bestTarget;\n        }\n\n        return null;\n    }\n\n    /**\n     * Get the filtered candidate among candidates.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}\n     * @function filteredCandidates\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param container {Node} - The spatial navigation container\n     * @returns {sequence<Node>} The filtered candidates which are not the search origin and not in the given spatial navigation direction from the search origin\n     */\n    // TODO: Need to fix filtering the candidates with more clean code\n    function filteredCandidates(currentElm, candidates, dir, container) {\n        const originalContainer = currentElm.getSpatialNavigationContainer();\n        let eventTargetRect;\n\n        // If D(dir) is null, let candidates be the same as visibles\n        if (dir === undefined) return candidates;\n\n        // Offscreen handling when originalContainer is not <HTML>\n        if (originalContainer.parentElement && container !== originalContainer && !isVisible(currentElm)) {\n            eventTargetRect = getBoundingClientRect(originalContainer);\n        } else {\n            eventTargetRect = searchOriginRect || getBoundingClientRect(currentElm);\n        }\n\n        /*\n         * Else, let candidates be the subset of the elements in visibles\n         * whose principal box’s geometric center is within the closed half plane\n         * whose boundary goes through the geometric center of starting point and is perpendicular to D.\n         */\n        if ((isContainer(currentElm) || currentElm.nodeName === 'BODY') && !(currentElm.nodeName === 'INPUT')) {\n            return candidates.filter((candidate) => {\n                const candidateRect = getBoundingClientRect(candidate);\n                return (\n                    container.contains(candidate) &&\n                    ((currentElm.contains(candidate) &&\n                        isInside(eventTargetRect, candidateRect) &&\n                        candidate !== currentElm) ||\n                        isOutside(candidateRect, eventTargetRect, dir))\n                );\n            });\n        } else {\n            return candidates.filter((candidate) => {\n                const candidateRect = getBoundingClientRect(candidate);\n                const candidateBody = candidate.nodeName === 'IFRAME' ? candidate.contentDocument.body : null;\n                return (\n                    container.contains(candidate) &&\n                    candidate !== currentElm &&\n                    candidateBody !== currentElm &&\n                    isOutside(candidateRect, eventTargetRect, dir) &&\n                    !isInside(eventTargetRect, candidateRect)\n                );\n            });\n        }\n    }\n\n    /**\n     * Select the best candidate among given candidates.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}\n     * @function selectBestCandidate\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function selectBestCandidate(currentElm, candidates, dir) {\n        const container = currentElm.getSpatialNavigationContainer();\n        const spatialNavigationFunction = getComputedStyle(container).getPropertyValue('--spatial-navigation-function');\n        const currentTargetRect = searchOriginRect || getBoundingClientRect(currentElm);\n        let distanceFunction;\n        let alignedCandidates;\n\n        switch (spatialNavigationFunction) {\n            case 'grid':\n                alignedCandidates = candidates.filter((elm) =>\n                    isAligned(currentTargetRect, getBoundingClientRect(elm), dir),\n                );\n                if (alignedCandidates.length > 0) {\n                    candidates = alignedCandidates;\n                }\n                distanceFunction = getAbsoluteDistance;\n                break;\n            default:\n                distanceFunction = getDistance;\n                break;\n        }\n        return getClosestElement(currentElm, candidates, dir, distanceFunction);\n    }\n\n    /**\n     * Select the best candidate among candidates by finding the closet candidate from the edge of the currently focused element (search origin).\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate (Step 5)}\n     * @function selectBestCandidateFromEdge\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function selectBestCandidateFromEdge(currentElm, candidates, dir) {\n        if (startingPoint) return getClosestElement(currentElm, candidates, dir, getDistanceFromPoint);\n        else return getClosestElement(currentElm, candidates, dir, getInnerDistance);\n    }\n\n    /**\n     * Select the closest candidate from the currently focused element (search origin) among candidates by using the distance function.\n     * @function getClosestElement\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param distanceFunction {function} - The distance function which measures the distance from the search origin to each candidate\n     * @returns {Node} The candidate which is the closest one from the search origin\n     */\n    function getClosestElement(currentElm, candidates, dir, distanceFunction) {\n        let eventTargetRect = null;\n        if (\n            window.location !== window.parent.location &&\n            (currentElm.nodeName === 'BODY' || currentElm.nodeName === 'HTML')\n        ) {\n            // If the eventTarget is iframe, then get rect of it based on its containing document\n            // Set the iframe's position as (0,0) because the rects of elements inside the iframe don't know the real iframe's position.\n            eventTargetRect = window.frameElement.getBoundingClientRect();\n            eventTargetRect.x = 0;\n            eventTargetRect.y = 0;\n        } else {\n            eventTargetRect = searchOriginRect || currentElm.getBoundingClientRect();\n        }\n\n        let minDistance = Number.POSITIVE_INFINITY;\n        let minDistanceElements = [];\n\n        if (candidates) {\n            for (let i = 0; i < candidates.length; i++) {\n                const distance = distanceFunction(eventTargetRect, getBoundingClientRect(candidates[i]), dir);\n\n                // If the same distance, the candidate will be selected in the DOM order\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minDistanceElements = [candidates[i]];\n                } else if (distance === minDistance) {\n                    minDistanceElements.push(candidates[i]);\n                }\n            }\n        }\n        if (minDistanceElements.length === 0) return null;\n\n        return minDistanceElements.length > 1 && distanceFunction === getAbsoluteDistance\n            ? getClosestElement(currentElm, minDistanceElements, dir, getEuclideanDistance)\n            : minDistanceElements[0];\n    }\n\n    /**\n     * Get container of an element.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-getspatialnavigationcontainer}\n     * @module Element\n     * @function getSpatialNavigationContainer\n     * @returns {Node} The spatial navigation container\n     */\n    function getSpatialNavigationContainer() {\n        let container = this;\n\n        do {\n            if (!container.parentElement) {\n                if (window.location !== window.parent.location) {\n                    container = window.parent.document.documentElement;\n                } else {\n                    container = window.document.documentElement;\n                }\n                break;\n            } else {\n                container = container.parentElement;\n            }\n\n            // console.log(container, isContainer(container));\n        } while (!isContainer(container));\n        return container;\n    }\n\n    /**\n     * Get nearest scroll container of an element.\n     * @function getScrollContainer\n     * @param Element\n     * @returns {Node} The spatial navigation container\n     */\n    function getScrollContainer(element) {\n        let scrollContainer = element;\n\n        do {\n            if (!scrollContainer.parentElement) {\n                if (window.location !== window.parent.location) {\n                    scrollContainer = window.parent.document.documentElement;\n                } else {\n                    scrollContainer = window.document.documentElement;\n                }\n                break;\n            } else {\n                scrollContainer = scrollContainer.parentElement;\n            }\n        } while (!isScrollContainer(scrollContainer) || !isVisible(scrollContainer));\n\n        if (scrollContainer === document || scrollContainer === document.documentElement) {\n            scrollContainer = window;\n        }\n\n        return scrollContainer;\n    }\n\n    /**\n     * Find focusable elements within the spatial navigation container.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-focusableareas}\n     * @function focusableAreas\n     * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.\n     *                                          Default value is 'visible'.\n     * @returns {sequence<Node>} All focusable elements or only visible focusable elements within the container\n     */\n    function focusableAreas(option = { mode: 'visible' }) {\n        const container = this.parentElement ? this : document.body;\n        const focusables = Array.prototype.filter.call(container.getElementsByTagName('*'), isFocusable);\n        return option.mode === 'all' ? focusables : focusables.filter(isVisible);\n    }\n\n    /**\n     * Create the NavigationEvent: navbeforefocus, navnotarget\n     * @see {@link https://drafts.csswg.org/css-nav-1/#events-navigationevent}\n     * @function createSpatNavEvents\n     * @param option {string} - Type of the navigation event (beforefocus, notarget)\n     * @param element {Node} - The target element of the event\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function createSpatNavEvents(eventType, containerElement, currentElement, direction) {\n        if (['beforefocus', 'notarget'].includes(eventType)) {\n            const data = {\n                causedTarget: currentElement,\n                dir: direction,\n            };\n            const triggeredEvent = new CustomEvent('nav' + eventType, {\n                bubbles: true,\n                cancelable: true,\n                detail: data,\n            });\n            return containerElement.dispatchEvent(triggeredEvent);\n        }\n    }\n\n    /**\n     * Get the value of the CSS custom property of the element\n     * @function readCssVar\n     * @param element {Node}\n     * @param varName {string} - The name of the css custom property without '--'\n     * @returns {string} The value of the css custom property\n     */\n    function readCssVar(element, varName) {\n        return getComputedStyle(element).getPropertyValue(`--${varName}`).trim();\n    }\n\n    /**\n     * Decide whether or not the 'contain' value is given to 'spatial-navigation-contain' css property of an element\n     * @function isCSSSpatNavContain\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isCSSSpatNavContain(element) {\n        return readCssVar(element, 'spatial-navigation-contain') === 'contain';\n    }\n\n    /**\n     * Return the value of 'spatial-navigation-action' css property of an element\n     * @function getCSSSpatNavAction\n     * @param element {Node} - would be the spatial navigation container\n     * @returns {string} auto | focus | scroll\n     */\n    function getCSSSpatNavAction(element) {\n        return 'focus';\n        //   return readCssVar(element, 'spatial-navigation-action') || 'auto';\n    }\n\n    /**\n     * Only move the focus with spatial navigation. Manually scrolling isn't available.\n     * @function navigateChain\n     * @param eventTarget {Node} - currently focused element\n     * @param container {SpatialNavigationContainer} - container\n     * @param parentContainer {SpatialNavigationContainer} - parent container\n     * @param option - visible || all\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function navigateChain(eventTarget, container, parentContainer, dir, option) {\n        let currentOption = {\n            candidates: getSpatialNavigationCandidates(container, { mode: option }),\n            container,\n        };\n        //   console.log(currentOption)\n\n        while (parentContainer) {\n            if (focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)) {\n                return;\n            } else {\n                if (option === 'visible' && scrollingController(container, dir)) return;\n                else {\n                    if (!createSpatNavEvents('notarget', container, eventTarget, dir)) return;\n\n                    // find the container\n                    if (container === document || container === document.documentElement) {\n                        if (window.location !== window.parent.location) {\n                            // The page is in an iframe. eventTarget needs to be reset because the position of the element in the iframe\n                            eventTarget = window.frameElement;\n                            container = eventTarget.ownerDocument.documentElement;\n                        }\n                    } else {\n                        container = parentContainer;\n                    }\n                    currentOption = {\n                        candidates: getSpatialNavigationCandidates(container, {\n                            mode: option,\n                        }),\n                        container,\n                    };\n                    let nextContainer = container.getSpatialNavigationContainer();\n\n                    if (nextContainer !== container) {\n                        parentContainer = nextContainer;\n                    } else {\n                        parentContainer = null;\n                    }\n                }\n            }\n        }\n\n        currentOption = {\n            candidates: getSpatialNavigationCandidates(container, { mode: option }),\n            container,\n        };\n\n        // Behavior after 'navnotarget' - Getting out from the current spatnav container\n        if (\n            !parentContainer &&\n            container &&\n            focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)\n        )\n            return;\n\n        if (!createSpatNavEvents('notarget', currentOption.container, eventTarget, dir)) return;\n\n        if (getCSSSpatNavAction(container) === 'auto' && option === 'visible') {\n            if (scrollingController(container, dir)) return;\n        }\n    }\n\n    /**\n     * Find search origin\n     * @see {@link https://drafts.csswg.org/css-nav-1/#nav}\n     * @function findSearchOrigin\n     * @returns {Node} The search origin for the spatial navigation\n     */\n    function findSearchOrigin() {\n        let searchOrigin = document.activeElement;\n\n        if (!searchOrigin || (searchOrigin === document.body && !document.querySelector(':focus'))) {\n            // When the previous search origin lost its focus by blur: (1) disable attribute (2) visibility: hidden\n            if (savedSearchOrigin.element && searchOrigin !== savedSearchOrigin.element) {\n                const elementStyle = window.getComputedStyle(savedSearchOrigin.element, null);\n                const invisibleStyle = ['hidden', 'collapse'];\n\n                if (\n                    savedSearchOrigin.element.disabled ||\n                    invisibleStyle.includes(elementStyle.getPropertyValue('visibility'))\n                ) {\n                    searchOrigin = savedSearchOrigin.element;\n                    return searchOrigin;\n                }\n            }\n            searchOrigin = document.documentElement;\n        }\n        // When the previous search origin lost its focus by blur: (1) display:none () element size turned into zero\n        if (\n            savedSearchOrigin.element &&\n            (getBoundingClientRect(savedSearchOrigin.element).height === 0 ||\n                getBoundingClientRect(savedSearchOrigin.element).width === 0)\n        ) {\n            (startingPoint = (savedSearchOrigin.left + savedSearchOrigin.right) / 2),\n            (savedSearchOrigin.top + savedSearchOrigin.bottom) / 2;\n            // searchOriginRect = savedSearchOrigin.rect;\n        }\n\n        if (!isVisibleInScroller(searchOrigin)) {\n            const scroller = getScrollContainer(searchOrigin);\n            if (scroller && (scroller === window || getCSSSpatNavAction(scroller) === 'auto')) return scroller;\n        }\n        return searchOrigin;\n    }\n\n    /**\n     * Move the scroll of an element depending on the given spatial navigation directrion\n     * (Assume that User Agent defined distance is '40px')\n     * @see {@link https://drafts.csswg.org/css-nav-1/#directionally-scroll-an-element}\n     * @function moveScroll\n     * @param element {Node} - The scrollable element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param offset {Number} - The explicit amount of offset for scrolling. Default value is 0.\n     */\n    function moveScroll(element, dir, offset = 0) {\n        if (element) {\n            switch (dir) {\n                case 'left':\n                    element.scrollLeft -= 40 + offset;\n                    break;\n                case 'right':\n                    element.scrollLeft += 40 + offset;\n                    break;\n                case 'up':\n                    element.scrollTop -= 40 + offset;\n                    break;\n                case 'down':\n                    element.scrollTop += 40 + offset;\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Decide whether an element is container or not.\n     * @function isContainer\n     * @param element {Node} element\n     * @returns {boolean}\n     */\n    function isContainer(element) {\n        return (\n            !element.parentElement ||\n            element.nodeName === 'IFRAME' ||\n            isScrollContainer(element) ||\n            isCSSSpatNavContain(element)\n        );\n    }\n\n    /**\n     * Decide whether an element is delegable container or not.\n     * NOTE: THIS IS NON-NORMATIVE API.\n     * @function isDelegableContainer\n     * @param element {Node} element\n     * @returns {boolean}\n     */\n    function isDelegableContainer(element) {\n        return readCssVar(element, 'spatial-navigation-contain') === 'delegable';\n    }\n\n    /**\n     * Decide whether an element is a scrollable container or not.\n     * @see {@link https://drafts.csswg.org/css-overflow-3/#scroll-container}\n     * @function isScrollContainer\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isScrollContainer(element) {\n        const elementStyle = window.getComputedStyle(element, null);\n        const overflowX = elementStyle.getPropertyValue('overflow-x');\n        const overflowY = elementStyle.getPropertyValue('overflow-y');\n\n        return (overflowX !== 'visible' && overflowX !== 'clip' && isOverflow(element, 'left')) ||\n        (overflowY !== 'visible' && overflowY !== 'clip' && isOverflow(element, 'down'))\n            ? true\n            : false;\n    }\n\n    /**\n     * Decide whether this element is scrollable or not.\n     * NOTE: If the value of 'overflow' is given to either 'visible', 'clip', or 'hidden', the element isn't scrollable.\n     *       If the value is 'hidden', the element can be only programmically scrollable. (https://drafts.csswg.org/css-overflow-3/#valdef-overflow-hidden)\n     * @function isScrollable\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isScrollable(element, dir) {\n        // element, dir\n        if (element && typeof element === 'object') {\n            if (dir && typeof dir === 'string') {\n                // parameter: dir, element\n                if (isOverflow(element, dir)) {\n                    // style property\n                    const elementStyle = window.getComputedStyle(element, null);\n                    const overflowX = elementStyle.getPropertyValue('overflow-x');\n                    const overflowY = elementStyle.getPropertyValue('overflow-y');\n\n                    switch (dir) {\n                        case 'left':\n                        /* falls through */\n                        case 'right':\n                            return overflowX !== 'visible' && overflowX !== 'clip' && overflowX !== 'hidden';\n                        case 'up':\n                        /* falls through */\n                        case 'down':\n                            return overflowY !== 'visible' && overflowY !== 'clip' && overflowY !== 'hidden';\n                    }\n                }\n                return false;\n            } else {\n                // parameter: element\n                return (\n                    element.nodeName === 'HTML' ||\n                    element.nodeName === 'BODY' ||\n                    (isScrollContainer(element) && isOverflow(element))\n                );\n            }\n        }\n    }\n\n    /**\n     * Decide whether an element is overflow or not.\n     * @function isOverflow\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isOverflow(element, dir) {\n        if (element && typeof element === 'object') {\n            if (dir && typeof dir === 'string') {\n                // parameter: element, dir\n                switch (dir) {\n                    case 'left':\n                    /* falls through */\n                    case 'right':\n                        return element.scrollWidth > element.clientWidth;\n                    case 'up':\n                    /* falls through */\n                    case 'down':\n                        return element.scrollHeight > element.clientHeight;\n                }\n            } else {\n                // parameter: element\n                return element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Decide whether the scrollbar of the browsing context reaches to the end or not.\n     * @function isHTMLScrollBoundary\n     * @param element {Node} - The top browsing context\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isHTMLScrollBoundary(element, dir) {\n        let result = false;\n        switch (dir) {\n            case 'left':\n                result = element.scrollLeft === 0;\n                break;\n            case 'right':\n                result = element.scrollWidth - element.scrollLeft - element.clientWidth === 0;\n                break;\n            case 'up':\n                result = element.scrollTop === 0;\n                break;\n            case 'down':\n                result = element.scrollHeight - element.scrollTop - element.clientHeight === 0;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Decide whether the scrollbar of an element reaches to the end or not.\n     * @function isScrollBoundary\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isScrollBoundary(element, dir) {\n        if (isScrollable(element, dir)) {\n            const winScrollY = element.scrollTop;\n            const winScrollX = element.scrollLeft;\n\n            const height = element.scrollHeight - element.clientHeight;\n            const width = element.scrollWidth - element.clientWidth;\n\n            switch (dir) {\n                case 'left':\n                    return winScrollX === 0;\n                case 'right':\n                    return Math.abs(winScrollX - width) <= 1;\n                case 'up':\n                    return winScrollY === 0;\n                case 'down':\n                    return Math.abs(winScrollY - height) <= 1;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Decide whether an element is inside the scorller viewport or not\n     *\n     * @function isVisibleInScroller\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isVisibleInScroller(element) {\n        const elementRect = element.getBoundingClientRect();\n        let nearestScroller = getScrollContainer(element);\n\n        let scrollerRect = null;\n        if (nearestScroller !== window) {\n            scrollerRect = getBoundingClientRect(nearestScroller);\n        } else {\n            scrollerRect = new DOMRect(0, 0, window.innerWidth, window.innerHeight);\n        }\n\n        if (isInside(scrollerRect, elementRect, 'left') && isInside(scrollerRect, elementRect, 'down')) return true;\n        else return false;\n    }\n\n    /**\n     * Decide whether an element is focusable for spatial navigation.\n     * 1. If element is the browsing context (document, iframe), then it's focusable,\n     * 2. If the element is scrollable container (regardless of scrollable axis), then it's focusable,\n     * 3. The value of tabIndex >= 0, then it's focusable,\n     * 4. If the element is disabled, it isn't focusable,\n     * 5. If the element is expressly inert, it isn't focusable,\n     * 6. Whether the element is being rendered or not.\n     *\n     * @function isFocusable\n     * @param element {Node}\n     * @returns {boolean}\n     *\n     * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#focusable-area}\n     */\n    function isFocusable(element) {\n        if (\n            element.tabIndex < 0 ||\n            isAtagWithoutHref(element) ||\n            isActuallyDisabled(element) ||\n            isExpresslyInert(element) ||\n            !isBeingRendered(element)\n        )\n            return false;\n        else if (!element.parentElement || (isScrollable(element) && isOverflow(element)) || element.tabIndex >= 0)\n            return true;\n    }\n\n    /**\n     * Decide whether an element is a tag without href attribute or not.\n     *\n     * @function isAtagWithoutHref\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isAtagWithoutHref(element) {\n        return (\n            element.tagName === 'A' &&\n            element.getAttribute('href') === null &&\n            element.getAttribute('tabIndex') === null\n        );\n    }\n\n    /**\n     * Decide whether an element is actually disabled or not.\n     *\n     * @function isActuallyDisabled\n     * @param element {Node}\n     * @returns {boolean}\n     *\n     * @see {@link https://html.spec.whatwg.org/multipage/semantics-other.html#concept-element-disabled}\n     */\n    function isActuallyDisabled(element) {\n        if (['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(element.tagName))\n            return element.disabled;\n        else return false;\n    }\n\n    /**\n     * Decide whether the element is expressly inert or not.\n     * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#expressly-inert}\n     * @function isExpresslyInert\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isExpresslyInert(element) {\n        return element.inert && !element.ownerDocument.documentElement.inert;\n    }\n\n    /**\n     * Decide whether the element is being rendered or not.\n     * 1. If an element has the style as \"visibility: hidden | collapse\" or \"display: none\", it is not being rendered.\n     * 2. If an element has the style as \"opacity: 0\", it is not being rendered.(that is, invisible).\n     * 3. If width and height of an element are explicitly set to 0, it is not being rendered.\n     * 4. If a parent element is hidden, an element itself is not being rendered.\n     * (CSS visibility property and display property are inherited.)\n     * @see {@link https://html.spec.whatwg.org/multipage/rendering.html#being-rendered}\n     * @function isBeingRendered\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isBeingRendered(element) {\n        if (!isVisibleStyleProperty(element.parentElement)) return false;\n        if (\n            !isVisibleStyleProperty(element) ||\n            element.style.opacity === '0' ||\n            window.getComputedStyle(element).height === '0px' ||\n            window.getComputedStyle(element).width === '0px'\n        )\n            return false;\n        return true;\n    }\n\n    /**\n     * Decide whether this element is partially or completely visible to user agent.\n     * @function isVisible\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isVisible(element) {\n        return !element.parentElement || (isVisibleStyleProperty(element) && hitTest(element));\n    }\n\n    /**\n     * Decide whether this element is completely visible in this viewport for the arrow direction.\n     * @function isEntirelyVisible\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isEntirelyVisible(element, container) {\n        const rect = getBoundingClientRect(element);\n        const containerElm = container || element.getSpatialNavigationContainer();\n        const containerRect = getBoundingClientRect(containerElm);\n\n        // FIXME: when element is bigger than container?\n        const entirelyVisible = !(\n            rect.left < containerRect.left ||\n            rect.right > containerRect.right ||\n            rect.top < containerRect.top ||\n            rect.bottom > containerRect.bottom\n        );\n\n        return entirelyVisible;\n    }\n\n    /**\n     * Decide the style property of this element is specified whether it's visible or not.\n     * @function isVisibleStyleProperty\n     * @param element {CSSStyleDeclaration}\n     * @returns {boolean}\n     */\n    function isVisibleStyleProperty(element) {\n        const elementStyle = window.getComputedStyle(element, null);\n        const thisVisibility = elementStyle.getPropertyValue('visibility');\n        const thisDisplay = elementStyle.getPropertyValue('display');\n        const invisibleStyle = ['hidden', 'collapse'];\n\n        return thisDisplay !== 'none' && !invisibleStyle.includes(thisVisibility);\n    }\n\n    /**\n     * Decide whether this element is entirely or partially visible within the viewport.\n     * @function hitTest\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function hitTest(element) {\n        const elementRect = getBoundingClientRect(element);\n        if (\n            element.nodeName !== 'IFRAME' &&\n            (elementRect.top < 0 ||\n                elementRect.left < 0 ||\n                elementRect.top > element.ownerDocument.documentElement.clientHeight ||\n                elementRect.left > element.ownerDocument.documentElement.clientWidth)\n        )\n            return false;\n\n        let offsetX = parseInt(element.offsetWidth) / 10;\n        let offsetY = parseInt(element.offsetHeight) / 10;\n\n        offsetX = isNaN(offsetX) ? 1 : offsetX;\n        offsetY = isNaN(offsetY) ? 1 : offsetY;\n\n        const hitTestPoint = {\n            // For performance, just using the three point(middle, leftTop, rightBottom) of the element for hit testing\n            middle: [(elementRect.left + elementRect.right) / 2, (elementRect.top + elementRect.bottom) / 2],\n            leftTop: [elementRect.left + offsetX, elementRect.top + offsetY],\n            rightBottom: [elementRect.right - offsetX, elementRect.bottom - offsetY],\n        };\n\n        for (const point in hitTestPoint) {\n            const elemFromPoint = element.ownerDocument.elementFromPoint(...hitTestPoint[point]);\n            if (element === elemFromPoint || element.contains(elemFromPoint)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Decide whether a child element is entirely or partially Included within container visually.\n     * @function isInside\n     * @param containerRect {DOMRect}\n     * @param childRect {DOMRect}\n     * @returns {boolean}\n     */\n    function isInside(containerRect, childRect) {\n        const rightEdgeCheck = containerRect.left < childRect.right && containerRect.right >= childRect.right;\n        const leftEdgeCheck = containerRect.left <= childRect.left && containerRect.right > childRect.left;\n        const topEdgeCheck = containerRect.top <= childRect.top && containerRect.bottom > childRect.top;\n        const bottomEdgeCheck = containerRect.top < childRect.bottom && containerRect.bottom >= childRect.bottom;\n        return (rightEdgeCheck || leftEdgeCheck) && (topEdgeCheck || bottomEdgeCheck);\n    }\n\n    /**\n     * Decide whether this element is entirely or partially visible within the viewport.\n     * Note: rect1 is outside of rect2 for the dir\n     * @function isOutside\n     * @param rect1 {DOMRect}\n     * @param rect2 {DOMRect}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isOutside(rect1, rect2, dir) {\n        switch (dir) {\n            case 'left':\n                return isRightSide(rect2, rect1);\n            case 'right':\n                return isRightSide(rect1, rect2);\n            case 'up':\n                return isBelow(rect2, rect1);\n            case 'down':\n                return isBelow(rect1, rect2);\n            default:\n                return false;\n        }\n    }\n\n    /* rect1 is right of rect2 */\n    function isRightSide(rect1, rect2) {\n        return (\n            rect1.left >= rect2.right ||\n            (rect1.left >= rect2.left &&\n                rect1.right > rect2.right &&\n                rect1.bottom > rect2.top &&\n                rect1.top < rect2.bottom)\n        );\n    }\n\n    /* rect1 is below of rect2 */\n    function isBelow(rect1, rect2) {\n        return (\n            rect1.top >= rect2.bottom ||\n            (rect1.top >= rect2.top &&\n                rect1.bottom > rect2.bottom &&\n                rect1.left < rect2.right &&\n                rect1.right > rect2.left)\n        );\n    }\n\n    /* rect1 is completely aligned or partially aligned for the direction */\n    function isAligned(rect1, rect2, dir) {\n        switch (dir) {\n            case 'left':\n            /* falls through */\n            case 'right':\n                return rect1.bottom > rect2.top && rect1.top < rect2.bottom;\n            case 'up':\n            /* falls through */\n            case 'down':\n                return rect1.right > rect2.left && rect1.left < rect2.right;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getDistanceFromPoint\n     * @param point {Point} - The search origin\n     * @param element {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The euclidian distance between the spatial navigation container and an element inside it\n     */\n    function getDistanceFromPoint(point, element, dir) {\n        point = startingPoint;\n        // Get exit point, entry point -> {x: '', y: ''};\n        const points = getEntryAndExitPoints(dir, point, element);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // The result is euclidian distance between P1 and P2.\n        return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n    }\n\n    /**\n     * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getInnerDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The euclidean distance between the spatial navigation container and an element inside it\n     */\n    function getInnerDistance(rect1, rect2, dir) {\n        const baseEdgeForEachDirection = {\n            left: 'right',\n            right: 'left',\n            up: 'bottom',\n            down: 'top',\n        };\n        const baseEdge = baseEdgeForEachDirection[dir];\n\n        return Math.abs(rect1[baseEdge] - rect2[baseEdge]);\n    }\n\n    /**\n     * Get the distance between the search origin and a candidate element considering the direction.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#calculating-the-distance}\n     * @function getDistance\n     * @param searchOrigin {DOMRect | Point} - The search origin\n     * @param candidateRect {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getDistance(searchOrigin, candidateRect, dir) {\n        const kOrthogonalWeightForLeftRight = 30;\n        const kOrthogonalWeightForUpDown = 2;\n\n        let orthogonalBias = 0;\n        let alignBias = 0;\n        const alignWeight = 5.0;\n\n        // Get exit point, entry point -> {x: '', y: ''};\n        const points = getEntryAndExitPoints(dir, searchOrigin, candidateRect);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // A: The euclidean distance between P1 and P2.\n        const A = Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n        let B, C;\n\n        // B: The absolute distance in the direction which is orthogonal to dir between P1 and P2, or 0 if dir is null.\n        // C: The intersection edges between a candidate and the starting point.\n\n        // D: The square root of the area of intersection between the border boxes of candidate and starting point\n        const intersectionRect = getIntersectionRect(searchOrigin, candidateRect);\n        const D = intersectionRect.area;\n\n        switch (dir) {\n            case 'left':\n            /* falls through */\n            case 'right':\n                // If two elements are aligned, add align bias\n                // else, add orthogonal bias\n                if (isAligned(searchOrigin, candidateRect, dir))\n                    alignBias = Math.min(intersectionRect.height / searchOrigin.height, 1);\n                else orthogonalBias = searchOrigin.height / 2;\n\n                B = (P2 + orthogonalBias) * kOrthogonalWeightForLeftRight;\n                C = alignWeight * alignBias;\n                break;\n\n            case 'up':\n            /* falls through */\n            case 'down':\n                // If two elements are aligned, add align bias\n                // else, add orthogonal bias\n                if (isAligned(searchOrigin, candidateRect, dir))\n                    alignBias = Math.min(intersectionRect.width / searchOrigin.width, 1);\n                else orthogonalBias = searchOrigin.width / 2;\n\n                B = (P1 + orthogonalBias) * kOrthogonalWeightForUpDown;\n                C = alignWeight * alignBias;\n                break;\n\n            default:\n                B = 0;\n                C = 0;\n                break;\n        }\n\n        return A + B - C - D;\n    }\n\n    /**\n     * Get the euclidean distance between the search origin and a candidate element considering the direction.\n     * @function getEuclideanDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getEuclideanDistance(rect1, rect2, dir) {\n        // Get exit point, entry point\n        const points = getEntryAndExitPoints(dir, rect1, rect2);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // Return the euclidean distance between P1 and P2.\n        return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n    }\n\n    /**\n     * Get the absolute distance between the search origin and a candidate element considering the direction.\n     * @function getAbsoluteDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getAbsoluteDistance(rect1, rect2, dir) {\n        // Get exit point, entry point\n        const points = getEntryAndExitPoints(dir, rect1, rect2);\n\n        // Return the absolute distance in the dir direction between P1 and P.\n        return dir === 'left' || dir === 'right'\n            ? Math.abs(points.entryPoint.x - points.exitPoint.x)\n            : Math.abs(points.entryPoint.y - points.exitPoint.y);\n    }\n\n    /**\n     * Get entry point and exit point of two elements considering the direction.\n     * @function getEntryAndExitPoints\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD). Default value for dir is 'down'.\n     * @param searchOrigin {DOMRect | Point} - The search origin which contains the exit point\n     * @param candidateRect {DOMRect} - One of candidates which contains the entry point\n     * @returns {Points} The exit point from the search origin and the entry point from a candidate\n     */\n    function getEntryAndExitPoints(dir = 'down', searchOrigin, candidateRect) {\n        /**\n         * User type definition for Point\n         * @typeof {Object} Points\n         * @property {Point} Points.entryPoint\n         * @property {Point} Points.exitPoint\n         */\n        const points = { entryPoint: { x: 0, y: 0 }, exitPoint: { x: 0, y: 0 } };\n\n        if (startingPoint) {\n            points.exitPoint = searchOrigin;\n\n            switch (dir) {\n                case 'left':\n                    points.entryPoint.x = candidateRect.right;\n                    break;\n                case 'up':\n                    points.entryPoint.y = candidateRect.bottom;\n                    break;\n                case 'right':\n                    points.entryPoint.x = candidateRect.left;\n                    break;\n                case 'down':\n                    points.entryPoint.y = candidateRect.top;\n                    break;\n            }\n\n            // Set orthogonal direction\n            switch (dir) {\n                case 'left':\n                case 'right':\n                    if (startingPoint.y <= candidateRect.top) {\n                        points.entryPoint.y = candidateRect.top;\n                    } else if (startingPoint.y < candidateRect.bottom) {\n                        points.entryPoint.y = startingPoint.y;\n                    } else {\n                        points.entryPoint.y = candidateRect.bottom;\n                    }\n                    break;\n\n                case 'up':\n                case 'down':\n                    if (startingPoint.x <= candidateRect.left) {\n                        points.entryPoint.x = candidateRect.left;\n                    } else if (startingPoint.x < candidateRect.right) {\n                        points.entryPoint.x = startingPoint.x;\n                    } else {\n                        points.entryPoint.x = candidateRect.right;\n                    }\n                    break;\n            }\n        } else {\n            // Set direction\n            switch (dir) {\n                case 'left':\n                    points.exitPoint.x = searchOrigin.left;\n                    points.entryPoint.x =\n                        candidateRect.right < searchOrigin.left ? candidateRect.right : searchOrigin.left;\n                    break;\n                case 'up':\n                    points.exitPoint.y = searchOrigin.top;\n                    points.entryPoint.y =\n                        candidateRect.bottom < searchOrigin.top ? candidateRect.bottom : searchOrigin.top;\n                    break;\n                case 'right':\n                    points.exitPoint.x = searchOrigin.right;\n                    points.entryPoint.x =\n                        candidateRect.left > searchOrigin.right ? candidateRect.left : searchOrigin.right;\n                    break;\n                case 'down':\n                    points.exitPoint.y = searchOrigin.bottom;\n                    points.entryPoint.y =\n                        candidateRect.top > searchOrigin.bottom ? candidateRect.top : searchOrigin.bottom;\n                    break;\n            }\n\n            // Set orthogonal direction\n            switch (dir) {\n                case 'left':\n                case 'right':\n                    if (isBelow(searchOrigin, candidateRect)) {\n                        points.exitPoint.y = searchOrigin.top;\n                        points.entryPoint.y =\n                            candidateRect.bottom < searchOrigin.top ? candidateRect.bottom : searchOrigin.top;\n                    } else if (isBelow(candidateRect, searchOrigin)) {\n                        points.exitPoint.y = searchOrigin.bottom;\n                        points.entryPoint.y =\n                            candidateRect.top > searchOrigin.bottom ? candidateRect.top : searchOrigin.bottom;\n                    } else {\n                        points.exitPoint.y = Math.max(searchOrigin.top, candidateRect.top);\n                        points.entryPoint.y = points.exitPoint.y;\n                    }\n                    break;\n\n                case 'up':\n                case 'down':\n                    if (isRightSide(searchOrigin, candidateRect)) {\n                        points.exitPoint.x = searchOrigin.left;\n                        points.entryPoint.x =\n                            candidateRect.right < searchOrigin.left ? candidateRect.right : searchOrigin.left;\n                    } else if (isRightSide(candidateRect, searchOrigin)) {\n                        points.exitPoint.x = searchOrigin.right;\n                        points.entryPoint.x =\n                            candidateRect.left > searchOrigin.right ? candidateRect.left : searchOrigin.right;\n                    } else {\n                        points.exitPoint.x = Math.max(searchOrigin.left, candidateRect.left);\n                        points.entryPoint.x = points.exitPoint.x;\n                    }\n                    break;\n            }\n        }\n\n        return points;\n    }\n\n    /**\n     * Find focusable elements within the container\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getIntersectionRect\n     * @param rect1 {DOMRect} - The search origin which contains the exit point\n     * @param rect2 {DOMRect} - One of candidates which contains the entry point\n     * @returns {IntersectionArea} The intersection area between two elements.\n     *\n     * @typeof {Object} IntersectionArea\n     * @property {Number} IntersectionArea.width\n     * @property {Number} IntersectionArea.height\n     */\n    function getIntersectionRect(rect1, rect2) {\n        const intersection_rect = { width: 0, height: 0, area: 0 };\n\n        const new_location = [Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)];\n        const new_max_point = [Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom)];\n\n        intersection_rect.width = Math.abs(new_location[0] - new_max_point[0]);\n        intersection_rect.height = Math.abs(new_location[1] - new_max_point[1]);\n\n        if (!(new_location[0] >= new_max_point[0] || new_location[1] >= new_max_point[1])) {\n            // intersecting-cases\n            intersection_rect.area = Math.sqrt(intersection_rect.width * intersection_rect.height);\n        }\n\n        return intersection_rect;\n    }\n\n    /**\n     * Handle the spatial navigation behavior for HTMLInputElement, HTMLTextAreaElement\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input|HTMLInputElement (MDN)}\n     * @function handlingEditableElement\n     * @param e {Event} - keydownEvent\n     * @returns {boolean}\n     */\n    function handlingEditableElement(e) {\n        const SPINNABLE_INPUT_TYPES = ['email', 'date', 'month', 'number', 'time', 'week'],\n            TEXT_INPUT_TYPES = ['password', 'text', 'search', 'tel', 'url', null];\n        const eventTarget = document.activeElement;\n        const startPosition = eventTarget.selectionStart;\n        const endPosition = eventTarget.selectionEnd;\n        const focusNavigableArrowKey = {\n            left: false,\n            up: false,\n            right: false,\n            down: false,\n        };\n\n        const dir = ARROW_KEY_CODE[e.keyCode];\n        if (dir === undefined) {\n            return focusNavigableArrowKey;\n        }\n\n        if (SPINNABLE_INPUT_TYPES.includes(eventTarget.getAttribute('type')) && (dir === 'up' || dir === 'down')) {\n            focusNavigableArrowKey[dir] = true;\n        } else if (TEXT_INPUT_TYPES.includes(eventTarget.getAttribute('type')) || eventTarget.nodeName === 'TEXTAREA') {\n            if (startPosition === endPosition) {\n                // if there isn't any selected text\n                if (startPosition === 0) {\n                    focusNavigableArrowKey.left = true;\n                    focusNavigableArrowKey.up = true;\n                }\n                if (endPosition === eventTarget.value.length) {\n                    focusNavigableArrowKey.right = true;\n                    focusNavigableArrowKey.down = true;\n                }\n            }\n        } else {\n            // HTMLDataListElement, HTMLSelectElement, HTMLOptGroup\n            focusNavigableArrowKey[dir] = true;\n        }\n\n        return focusNavigableArrowKey;\n    }\n\n    /**\n     * Get the DOMRect of an element\n     * @function getBoundingClientRect\n     * @param {Node} element\n     * @returns {DOMRect}\n     */\n    function getBoundingClientRect(element) {\n        // memoization\n        let rect = mapOfBoundRect && mapOfBoundRect.get(element);\n        if (!rect) {\n            const boundingClientRect = element.getBoundingClientRect();\n            rect = {\n                top: Number(boundingClientRect.top.toFixed(2)),\n                right: Number(boundingClientRect.right.toFixed(2)),\n                bottom: Number(boundingClientRect.bottom.toFixed(2)),\n                left: Number(boundingClientRect.left.toFixed(2)),\n                width: Number(boundingClientRect.width.toFixed(2)),\n                height: Number(boundingClientRect.height.toFixed(2)),\n            };\n            mapOfBoundRect && mapOfBoundRect.set(element, rect);\n        }\n        return rect;\n    }\n\n    /**\n     * Get the candidates which is fully inside the target element in visual\n     * @param {Node} targetElement\n     * @returns {sequence<Node>}  overlappedCandidates\n     */\n    function getOverlappedCandidates(targetElement) {\n        const container = targetElement.getSpatialNavigationContainer();\n        const candidates = container.focusableAreas();\n        const overlappedCandidates = [];\n\n        candidates.forEach((element) => {\n            if (targetElement !== element && isEntirelyVisible(element, targetElement)) {\n                overlappedCandidates.push(element);\n            }\n        });\n\n        return overlappedCandidates;\n    }\n\n    /**\n     * Get the list of the experimental APIs\n     * @function getExperimentalAPI\n     */\n    function getExperimentalAPI() {\n        function canScroll(container, dir) {\n            return (\n                (isScrollable(container, dir) && !isScrollBoundary(container, dir)) ||\n                (!container.parentElement && !isHTMLScrollBoundary(container, dir))\n            );\n        }\n\n        function findTarget(findCandidate, element, dir, option) {\n            let eventTarget = element;\n            let bestNextTarget = null;\n\n            // 4\n            if (eventTarget === document || eventTarget === document.documentElement) {\n                eventTarget = document.body || document.documentElement;\n            }\n\n            // 5\n            // At this point, spatialNavigationSearch can be applied.\n            // If startingPoint is either a scroll container or the document,\n            // find the best candidate within startingPoint\n            if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {\n                if (eventTarget.nodeName === 'IFRAME') eventTarget = eventTarget.contentDocument.body;\n\n                const candidates = getSpatialNavigationCandidates(eventTarget, option);\n\n                // 5-2\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    return findCandidate\n                        ? getFilteredSpatialNavigationCandidates(eventTarget, dir, candidates)\n                        : eventTarget.spatialNavigationSearch(dir, { candidates });\n                }\n                if (canScroll(eventTarget, dir)) {\n                    return findCandidate ? [] : eventTarget;\n                }\n            }\n\n            // 6\n            // Let container be the nearest ancestor of eventTarget\n            let container = eventTarget.getSpatialNavigationContainer();\n            let parentContainer = container.parentElement ? container.getSpatialNavigationContainer() : null;\n\n            // When the container is the viewport of a browsing context\n            if (!parentContainer && window.location !== window.parent.location) {\n                parentContainer = window.parent.document.documentElement;\n            }\n\n            // 7\n            while (parentContainer) {\n                const candidates = filteredCandidates(\n                    eventTarget,\n                    getSpatialNavigationCandidates(container, option),\n                    dir,\n                    container,\n                );\n\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    bestNextTarget = eventTarget.spatialNavigationSearch(dir, {\n                        candidates,\n                        container,\n                    });\n                    if (bestNextTarget) {\n                        return findCandidate ? candidates : bestNextTarget;\n                    }\n                }\n\n                    // If there isn't any candidate and the best candidate among candidate:\n                    // 1) Scroll or 2) Find candidates of the ancestor container\n                // 8 - if\n                else if (canScroll(container, dir)) {\n                    return findCandidate ? [] : eventTarget;\n                } else if (container === document || container === document.documentElement) {\n                    container = window.document.documentElement;\n\n                    // The page is in an iframe\n                    if (window.location !== window.parent.location) {\n                        // eventTarget needs to be reset because the position of the element in the IFRAME\n                        // is unuseful when the focus moves out of the iframe\n                        eventTarget = window.frameElement;\n                        container = window.parent.document.documentElement;\n                        if (container.parentElement) parentContainer = container.getSpatialNavigationContainer();\n                        else {\n                            parentContainer = null;\n                            break;\n                        }\n                    }\n                } else {\n                    // avoiding when spatnav container with tabindex=-1\n                    if (isFocusable(container)) {\n                        eventTarget = container;\n                    }\n\n                    container = parentContainer;\n                    if (container.parentElement) parentContainer = container.getSpatialNavigationContainer();\n                    else {\n                        parentContainer = null;\n                        break;\n                    }\n                }\n            }\n\n            if (!parentContainer && container) {\n                // Getting out from the current spatnav container\n                const candidates = filteredCandidates(\n                    eventTarget,\n                    getSpatialNavigationCandidates(container, option),\n                    dir,\n                    container,\n                );\n\n                // 9\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    bestNextTarget = eventTarget.spatialNavigationSearch(dir, {\n                        candidates,\n                        container,\n                    });\n                    if (bestNextTarget) {\n                        return findCandidate ? candidates : bestNextTarget;\n                    }\n                }\n            }\n\n            if (canScroll(container, dir)) {\n                bestNextTarget = eventTarget;\n                return bestNextTarget;\n            }\n        }\n\n        return {\n            isContainer,\n            isScrollContainer,\n            isVisibleInScroller,\n            findCandidates: findTarget.bind(null, true),\n            findNextTarget: findTarget.bind(null, false),\n            getDistanceFromTarget: (element, candidateElement, dir) => {\n                if ((isContainer(element) || element.nodeName === 'BODY') && !(element.nodeName === 'INPUT')) {\n                    if (getSpatialNavigationCandidates(element).includes(candidateElement)) {\n                        return getInnerDistance(\n                            getBoundingClientRect(element),\n                            getBoundingClientRect(candidateElement),\n                            dir,\n                        );\n                    }\n                }\n                return getDistance(getBoundingClientRect(element), getBoundingClientRect(candidateElement), dir);\n            },\n        };\n    }\n\n    /**\n     * Makes to use the experimental APIs.\n     * @function enableExperimentalAPIs\n     * @param option {boolean} - If it is true, the experimental APIs can be used or it cannot.\n     */\n    function enableExperimentalAPIs(option) {\n        const currentKeyMode = window.__spatialNavigation__ && window.__spatialNavigation__.keyMode;\n        window.__spatialNavigation__ =\n            option === false ? getInitialAPIs() : Object.assign(getInitialAPIs(), getExperimentalAPI());\n        window.__spatialNavigation__.keyMode = currentKeyMode;\n        Object.seal(window.__spatialNavigation__);\n    }\n\n    /**\n     * Set the environment for using the spatial navigation polyfill.\n     * @function getInitialAPIs\n     */\n    function getInitialAPIs() {\n        return {\n            enableExperimentalAPIs,\n            get keyMode() {\n                return this._keymode ? this._keymode : 'ARROW';\n            },\n            set keyMode(mode) {\n                this._keymode = ['SHIFTARROW', 'ARROW', 'NONE'].includes(mode) ? mode : 'ARROW';\n            },\n            setStartingPoint: function (x, y) {\n                startingPoint = x && y ? { x, y } : null;\n            },\n        };\n    }\n\n    initiateSpatialNavigation();\n    enableExperimentalAPIs(true);\n\n    window.addEventListener('load', () => {\n        spatialNavigationHandler();\n    });\n})();\n\nlet currentSpatialNavigationContainer = null;\n\ndocument.addEventListener('navbeforefocus', (e) => {\n    if (e.target instanceof HTMLElement) {\n        e.preventDefault();\n\n        let { target } = e;\n\n        // focus on the first element when changing spatnav container\n        // const nextSpatialNavigationContainer = target.getSpatialNavigationContainer();\n        //\n        // if (currentSpatialNavigationContainer && currentSpatialNavigationContainer !== nextSpatialNavigationContainer) {\n        //     if (nextSpatialNavigationContainer.__lastElementFocused) {\n        //         target = nextSpatialNavigationContainer.__lastElementFocused;\n        //     } else {\n        //         [target] = nextSpatialNavigationContainer.focusableAreas({ mode: 'all' });\n        //     }\n        //     // target.focus();\n        // }\n        //\n        // currentSpatialNavigationContainer = nextSpatialNavigationContainer;\n        // currentSpatialNavigationContainer.__lastElementFocused = target;\n\n        requestAnimationFrame(async () => {\n            target.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });\n            // if (isElementInViewport(target)) {\n            //     target.focus();\n            // }\n\n            await new Promise((resolve) => {\n                const intersectionObserver = new IntersectionObserver(\n                    ([entry]) => {\n                        if (entry.isIntersecting) {\n                            resolve();\n                        }\n                    },\n                    {\n                        threshold: 1,\n                    },\n                );\n                intersectionObserver.observe(target);\n            });\n\n            target.focus();\n        });\n    }\n});\n\nexport const throttle = (callback, timeout) => {\n    let timeoutId = 0;\n\n    return () => {\n        if (timeoutId) {\n            return;\n        }\n\n        timeoutId = setTimeout(() => timeoutId = 0, timeout);\n\n        callback();\n    };\n};\n\nconst throttledClickToActiveElement = throttle(() => {\n    if (document.activeElement && !(document.activeElement instanceof HTMLButtonElement)) {\n        document.activeElement.click();\n    }\n}, 500);\n\ndocument.addEventListener('keyup', (event) => {\n    if (event.keyCode === 13) {\n        event.preventDefault();\n\n        throttledClickToActiveElement();\n    }\n});\n\n// console.log('1');\n\n// let isIntersecting = false;\n// const intersectionObserver = new IntersectionObserver(([entry]) => {\n// console.log('2');\n//   isIntersecting = entry.isIntersecting;\n// }, {\n//   threshold: 1\n// });\n// intersectionObserver.observe($0)\n// console.log('3');\n\n// start observing\n// intersectionObserver.observe());\n\nfunction isElementInViewport(el) {\n    const rect = el.getBoundingClientRect();\n    return (\n        rect.top >= 0 &&\n        rect.left >= 0 &&\n        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n        rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n    );\n}\n","import 'core-js';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Router } from 'react-router-dom';\nimport history from 'tools/history';\nimport store from 'stores';\nimport { setStore } from 'tools/connect';\nimport { Root } from 'components/Root/Root';\n\nimport 'tools/new-spatial-navigation';\n\nsetStore(store);\n\nif (process.env.REACT_APP_ENVIRONMENT === 'development') {\n    window.store = store;\n    const makeInspectable = require('mobx-devtools-mst'); // eslint-disable-line\n    makeInspectable.default(store);\n}\n\nconst APP_ROOT_ID = 'application_root';\n\nexport function renderApp(App: React.FC) {\n    ReactDOM.render(\n        <Router history={history}>\n            <App />\n        </Router>,\n        document.getElementById(APP_ROOT_ID),\n    );\n}\n\nrenderApp(Root);\n\nif (process.env.REACT_APP_ENVIRONMENT !== 'production' && module.hot) {\n    module.hot.accept('./components/Root/Root', () => {\n        // eslint-disable-next-line\n        const { Root } = require('./components/Root/Root.tsx');\n        renderApp(Root);\n    });\n}\n","module.exports = __webpack_public_path__ + \"static/media/figure-1.cad64c9b.svg\";"],"sourceRoot":""}