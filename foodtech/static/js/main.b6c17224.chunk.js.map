{"version":3,"sources":["tools/new-spatial-navigation.js","tools/history.js","stores/user.ts","stores/ui.ts","stores/product.ts","stores/products.ts","stores/cart.ts","stores/casts.ts","stores/index.ts","tools/connect.tsx","tools/bem.ts","hoc/withBem.tsx","components/Header/Header.tsx","components/HeaderAddress/HeaderAddress.tsx","tools/index.tsx","components/HeaderCart/HeaderCart.tsx","hooks/useFocusOnMount.tsx","pages/Catalog/ListItem/CatalogListItem.tsx","pages/Catalog/List/CatalogList.tsx","components/Skeleton/Skeleton.tsx","pages/Catalog/Skeleton/CatalogSkeleton.tsx","pages/Catalog/Catalog.tsx","components/Button/Button.tsx","pages/Cart/Info/CartInfo.tsx","pages/Cart/ListItem/CartListItem.tsx","pages/Cart/List/CartList.tsx","pages/Cart/Cart.tsx","pages/Status/Status.tsx","pages/Promo/Promo.tsx","hooks/useInterval.tsx","pages/NoArea/NoArea.tsx","pages/ScreenSaver/ScreenSaver.tsx","pages/AddressSimple/AddressSimple.tsx","components/Root/Root.tsx","index.tsx"],"names":["window","ARROW_KEY_CODE","37","38","39","40","mapOfBoundRect","startingPoint","savedSearchOrigin","element","rect","spatialNavigationHandler","addEventListener","e","currentKeyMode","parent","__spatialNavigation__","keyMode","eventTarget","document","activeElement","dir","keyCode","shiftKey","ctrlKey","metaKey","altKey","defaultPrevented","focusNavigableArrowKey","left","up","right","down","nodeName","startPosition","selectionStart","endPosition","selectionEnd","undefined","includes","getAttribute","value","length","handlingEditableElement","preventDefault","Map","navigate","x","clientX","y","clientY","target","getBoundingClientRect","searchOrigin","body","querySelector","elementStyle","getComputedStyle","invisibleStyle","disabled","getPropertyValue","documentElement","height","width","top","bottom","isVisibleInScroller","scroller","getScrollContainer","findSearchOrigin","console","log","elementFromPosition","elementFromPoint","isFocusable","isContainer","getSpatialNavigationContainer","container","contentDocument","bestInsideCandidate","spatialNavigationSearch","candidates","getSpatialNavigationCandidates","mode","focusingController","parentContainer","parentElement","location","navigateChain","bestCandidate","createSpatNavEvents","focus","preventScroll","scrollingController","isScrollable","isScrollBoundary","moveScroll","isHTMLScrollBoundary","ownerDocument","option","childElementCount","getElementsByTagName","children","elem","isDelegableContainer","push","concat","filter","isVisible","getFilteredSpatialNavigationCandidates","targetElement","filteredCandidates","args","this","bestTarget","internalCandidates","externalCandidates","insideOverlappedCandidates","focusableAreas","overlappedCandidates","forEach","isEntirelyVisible","getOverlappedCandidates","defaultContainer","defaultCandidates","contains","candidate","fullyOverlapped","overlappedByParent","map","elm","flat","currentElm","getClosestElement","getDistanceFromPoint","getInnerDistance","selectBestCandidateFromEdge","selectBestCandidate","innerTarget","descendantsBest","splice","indexOf","originalContainer","eventTargetRect","candidateRect","candidateBody","isOutside","isInside","spatialNavigationFunction","currentTargetRect","distanceFunction","alignedCandidates","isAligned","getAbsoluteDistance","getDistance","frameElement","minDistance","Number","POSITIVE_INFINITY","minDistanceElements","i","distance","getEuclideanDistance","scrollContainer","isScrollContainer","focusables","Array","prototype","call","eventType","containerElement","currentElement","direction","triggeredEvent","CustomEvent","bubbles","cancelable","detail","causedTarget","dispatchEvent","readCssVar","varName","trim","currentOption","nextContainer","offset","scrollLeft","scrollTop","isCSSSpatNavContain","overflowX","overflowY","isOverflow","scrollWidth","clientWidth","scrollHeight","clientHeight","result","winScrollY","winScrollX","Math","abs","elementRect","nearestScroller","scrollerRect","DOMRect","innerWidth","innerHeight","tabIndex","tagName","isAtagWithoutHref","isActuallyDisabled","inert","isExpresslyInert","isVisibleStyleProperty","style","opacity","isBeingRendered","offsetX","parseInt","offsetWidth","offsetY","offsetHeight","isNaN","hitTestPoint","middle","leftTop","rightBottom","point","elemFromPoint","hitTest","containerRect","thisVisibility","childRect","rightEdgeCheck","leftEdgeCheck","topEdgeCheck","bottomEdgeCheck","rect1","rect2","isRightSide","isBelow","points","getEntryAndExitPoints","P1","entryPoint","exitPoint","P2","sqrt","pow","baseEdge","orthogonalBias","alignBias","A","B","C","intersectionRect","intersection_rect","area","new_location","max","new_max_point","min","getIntersectionRect","D","get","boundingClientRect","toFixed","set","enableExperimentalAPIs","getInitialAPIs","Object","assign","canScroll","findTarget","findCandidate","bestNextTarget","isArray","findCandidates","bind","findNextTarget","getDistanceFromTarget","candidateElement","getExperimentalAPI","seal","_keymode","setStartingPoint","__getSpatNavState","searchOriginRect","Element","CSS","registerProperty","name","syntax","inherits","initialValue","currentSpatialNavigationContainer","HTMLElement","nextSpatialNavigationContainer","__lastElementFocused","requestAnimationFrame","async","scrollIntoView","behavior","block","inline","Promise","resolve","IntersectionObserver","entry","isIntersecting","threshold","observe","event","HTMLButtonElement","click","createHashHistory","User","types","model","address","maybeNull","string","phoneNumber","actions","self","updateUser","user","applySnapshot","routes","Ui","page","optional","enumeration","values","SCREEN_SAVER","previous","ui","gotoPage","to","history","goToCart","CART","AssistantClient","sendData","action_id","ProductItem","id","identifier","clearName","price","number","imagesUrls","array","quantityLeft","Products","title","items","selectedId","CartItem","product","reference","count","Cart","orderId","views","reduce","acc","item","floor","cart","clear","cast","addToCart","itemId","find","removeFromCart","shouldRemoveMention","index","findIndex","makePurchase","goTo","store","casts","SHOW_ITEMS","command","snapshot","stock","guid","clear_name","images_urls","quantity_left","products","ADD_ITEM","REMOVE_ITEM","REMOVE_ALL","GO_TO_VALIDATION","GO_TO_NO_AREA","NO_AREA","GO_TO_ADDRESS_SIMPLE","PROMO","GO_TO_CATALOG","address_string","CATALOG","VALIDATION_OK","STATUS","onMessage","message","smart_app_data","castFn","afterCreate","AssistantHost","ready","create","castFromStore","currentScreen","foodtech","keys","itemsMap","quantity","totalPrice","discountValue","__store","__inbox","__outbox","onStart","onData","JSON","stringify","onRequestState","state","updateState","connect","selector","baseComponent","component","ownProps","Error","useObserver","displayName","connectToStore","storeData","PREFIX","cssPrefix","blockName","delimeter","modDelimeter","renderer","elements","join","mod","modVal","modify","conditions","elemToModify","entries","predicate","Boolean","all","Component","componentName","props","context","bem","Bem","Header","withBem","className","HeaderAddress","onClick","ADDRESS_SIMPLE","splitByThousands","data","split","reduceRight","arr","HeaderCart","String","useFocusOnMount","ref","React","useRef","useLayoutEffect","current","CatalogListItem","countInCart","mountRef","selected","setSelected","useState","hasNoMoreItems","badgeType","onBlur","onFocus","backgroundImage","CatalogList","mountFocusRef","key","Skeleton","itemWidth","itemHeight","borderRadius","rowCount","columnCount","paddingBetweenColumns","paddingBetweenRows","list","from","_","columnIndex","rowIndex","rx","ry","CatalogSkeleton","viewBox","backgroundColor","foregroundColor","speed","Catalog","useEffect","process","Button","shouldFocusOnMount","type","CartInfo","hasPersonalData","big","small","addAddressInfo","CartListItem","onLessClick","onMoreClick","onSelect","setFocus","memoizedOnFocus","useCallback","aria-label","less","remove","more","onScroll","currentTarget","getOffset","itemsCount","relatedIndex","CartList","selectedItemIndex","setSelectedItemIndex","isFirstItemSelected","isLastItemSelected","wrapperStyle","transform","hidden","Status","Promo","currentIndex","setIndex","callback","timeout","POPCORN_TYPES_COUNT","intervalId","setInterval","clearInterval","NoArea","ScreenSaver","AddressSimple","Root","path","renderApp","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.b6c17224.chunk.js","sourcesContent":["/* eslint-disable */\n\n/* Spatial Navigation Polyfill\n *\n * It follows W3C official specification\n * https://drafts.csswg.org/css-nav-1/\n *\n * Copyright (c) 2018-2019 LG Electronics Inc.\n * https://github.com/WICG/spatial-navigation/polyfill\n *\n * Licensed under the MIT license (MIT)\n */\n\n(function () {\n    // The polyfill must not be executed, if it's already enabled via browser engine or browser extensions.\n    if ('navigate' in window) {\n        return;\n    }\n\n    const ARROW_KEY_CODE = { 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n    const TAB_KEY_CODE = 9;\n    let mapOfBoundRect = null;\n    let startingPoint = null; // Saves spatial navigation starting point\n    let savedSearchOrigin = { element: null, rect: null }; // Saves previous search origin\n    let searchOriginRect = null; // Rect of current search origin\n\n    window.__getSpatNavState = () => {\n        return {\n            mapOfBoundRect,\n            startingPoint,\n            savedSearchOrigin,\n            searchOriginRect,\n        };\n    };\n\n    /**\n     * Initiate the spatial navigation features of the polyfill.\n     * @function initiateSpatialNavigation\n     */\n    function initiateSpatialNavigation() {\n        /*\n         * Bind the standards APIs to be exposed to the window object for authors\n         */\n        window.navigate = navigate;\n        window.Element.prototype.spatialNavigationSearch = spatialNavigationSearch;\n        window.Element.prototype.focusableAreas = focusableAreas;\n        window.Element.prototype.getSpatialNavigationContainer = getSpatialNavigationContainer;\n\n        /*\n         * CSS.registerProperty() from the Properties and Values API\n         * Reference: https://drafts.css-houdini.org/css-properties-values-api/#the-registerproperty-function\n         */\n        if (window.CSS && CSS.registerProperty) {\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-contain') ===\n                ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-contain',\n                    syntax: 'auto | contain',\n                    inherits: false,\n                    initialValue: 'auto',\n                });\n            }\n\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-action') === ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-action',\n                    syntax: 'auto | focus | scroll',\n                    inherits: false,\n                    initialValue: 'auto',\n                });\n            }\n\n            if (\n                window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-function') ===\n                ''\n            ) {\n                CSS.registerProperty({\n                    name: '--spatial-navigation-function',\n                    syntax: 'normal | grid',\n                    inherits: false,\n                    initialValue: 'normal',\n                });\n            }\n        }\n    }\n\n    /**\n     * Add event handlers for the spatial navigation behavior.\n     * This function defines which input methods trigger the spatial navigation behavior.\n     * @function spatialNavigationHandler\n     */\n    function spatialNavigationHandler() {\n        /*\n         * keydown EventListener :\n         * If arrow key pressed, get the next focusing element and send it to focusing controller\n         */\n        window.addEventListener('keydown', (e) => {\n            const currentKeyMode =\n                (parent && parent.__spatialNavigation__.keyMode) || window.__spatialNavigation__.keyMode;\n            const eventTarget = document.activeElement;\n            const dir = ARROW_KEY_CODE[e.keyCode];\n\n            if (e.keyCode === TAB_KEY_CODE) {\n                startingPoint = null;\n            }\n\n            if (\n                !currentKeyMode ||\n                currentKeyMode === 'NONE' ||\n                (currentKeyMode === 'SHIFTARROW' && !e.shiftKey) ||\n                (currentKeyMode === 'ARROW' && e.shiftKey) ||\n                e.ctrlKey ||\n                e.metaKey ||\n                e.altKey\n            )\n                return;\n\n            if (!e.defaultPrevented) {\n                let focusNavigableArrowKey = {\n                    left: true,\n                    up: true,\n                    right: true,\n                    down: true,\n                };\n\n                // Edge case (text input, area) : Don't move focus, just navigate cursor in text area\n                if (eventTarget.nodeName === 'INPUT' || eventTarget.nodeName === 'TEXTAREA') {\n                    focusNavigableArrowKey = handlingEditableElement(e);\n                }\n\n                if (focusNavigableArrowKey[dir]) {\n                    e.preventDefault();\n                    mapOfBoundRect = new Map();\n\n                    navigate(dir);\n\n                    mapOfBoundRect = null;\n                    startingPoint = null;\n                }\n            }\n        });\n\n        /*\n         * mouseup EventListener :\n         * If the mouse click a point in the page, the point will be the starting point.\n         * NOTE: Let UA set the spatial navigation starting point based on click\n         */\n        document.addEventListener('mouseup', (e) => {\n            startingPoint = { x: e.clientX, y: e.clientY };\n        });\n\n        /*\n         * focusin EventListener :\n         * When the element get the focus, save it and its DOMRect for resetting the search origin\n         * if it disappears.\n         */\n        window.addEventListener('focusin', (e) => {\n            if (e.target !== window) {\n                savedSearchOrigin.element = e.target;\n                savedSearchOrigin.rect = e.target.getBoundingClientRect();\n            }\n        });\n    }\n\n    /**\n     * Enable the author to trigger spatial navigation programmatically, as if the user had done so manually.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-window-navigate}\n     * @function navigate\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function navigate(dir) {\n        // spatial navigation steps\n\n        // 1\n        const searchOrigin = findSearchOrigin();\n        console.log(searchOrigin);\n        let eventTarget = searchOrigin;\n        let elementFromPosition = null;\n\n        // 2 Optional step, UA defined starting point\n        if (startingPoint) {\n            // if there is a starting point, set eventTarget as the element from position for getting the spatnav container\n            elementFromPosition = document.elementFromPoint(startingPoint.x, startingPoint.y);\n\n            // Use starting point if the starting point isn't inside the focusable element (but not container)\n            // * Starting point is meaningfull when:\n            // 1) starting point is inside the spatnav container\n            // 2) starting point is inside the non-focusable element\n            if (elementFromPosition === null) {\n                elementFromPosition = document.body;\n            }\n            if (isFocusable(elementFromPosition) && !isContainer(elementFromPosition)) {\n                startingPoint = null;\n            } else if (isContainer(elementFromPosition)) {\n                eventTarget = elementFromPosition;\n            } else {\n                eventTarget = elementFromPosition.getSpatialNavigationContainer();\n            }\n        }\n\n        // 4\n        if (eventTarget === window || eventTarget === document || eventTarget === document.documentElement) {\n            eventTarget = document.body || document.documentElement;\n        }\n\n        // 5\n        // At this point, spatialNavigationSearch can be applied.\n        // If startingPoint is either a scroll container or the document,\n        // find the best candidate within startingPoint\n        let container = null;\n        if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {\n            if (eventTarget.nodeName === 'IFRAME') {\n                eventTarget = eventTarget.contentDocument.documentElement;\n            }\n\n            container = container === window ? document.body : eventTarget;\n            let bestInsideCandidate = null;\n\n            // 5-2\n            if (\n                document.activeElement === searchOrigin ||\n                (document.activeElement === document.body && searchOrigin === document.documentElement)\n            ) {\n                if (getCSSSpatNavAction(eventTarget) === 'scroll') {\n                    if (scrollingController(eventTarget, dir)) return;\n                } else if (getCSSSpatNavAction(eventTarget) === 'focus') {\n                    bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, {\n                        container: eventTarget,\n                        candidates: getSpatialNavigationCandidates(eventTarget, {\n                            mode: 'all',\n                        }),\n                    });\n                    if (focusingController(bestInsideCandidate, dir)) return;\n                } else if (getCSSSpatNavAction(eventTarget) === 'auto') {\n                    bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, {\n                        container: eventTarget,\n                    });\n                    if (focusingController(bestInsideCandidate, dir) || scrollingController(eventTarget, dir)) return;\n                }\n            } else {\n                // when the previous search origin became offscreen\n                container = container.getSpatialNavigationContainer();\n            }\n        }\n\n        // 6\n        // Let container be the nearest ancestor of eventTarget\n        container = eventTarget.getSpatialNavigationContainer();\n        let parentContainer = container.parentElement ? container.getSpatialNavigationContainer() : null;\n\n        // When the container is the viewport of a browsing context\n        if (!parentContainer && window.location !== window.parent.location) {\n            parentContainer = window.parent.document.documentElement;\n        }\n\n        if (getCSSSpatNavAction(container) === 'scroll') {\n            if (scrollingController(container, dir)) return;\n        } else if (getCSSSpatNavAction(container) === 'focus') {\n            navigateChain(eventTarget, container, parentContainer, dir, 'all');\n        } else if (getCSSSpatNavAction(container) === 'auto') {\n            navigateChain(eventTarget, container, parentContainer, dir, 'visible');\n        }\n    }\n\n    /**\n     * Move the focus to the best candidate or do nothing.\n     * @function focusingController\n     * @param bestCandidate {Node} - The best candidate of the spatial navigation\n     * @param dir {SpatialNavigationDirection}- The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function focusingController(bestCandidate, dir) {\n        // 10 & 11\n        // When bestCandidate is found\n        if (bestCandidate) {\n            // When bestCandidate is a focusable element and not a container : move focus\n            /*\n             * [event] navbeforefocus : Fired before spatial or sequential navigation changes the focus.\n             */\n            if (!createSpatNavEvents('beforefocus', bestCandidate, null, dir)) return true;\n\n            const container = bestCandidate.getSpatialNavigationContainer();\n\n            if (container !== window && getCSSSpatNavAction(container) === 'focus') {\n                bestCandidate.focus();\n            } else {\n                bestCandidate.focus({ preventScroll: true });\n            }\n\n            startingPoint = null;\n            return true;\n        }\n\n        // When bestCandidate is not found within the scrollport of a container: Nothing\n        return false;\n    }\n\n    /**\n     * Directionally scroll the scrollable spatial navigation container if it can be manually scrolled more.\n     * @function scrollingController\n     * @param container {Node} - The spatial navigation container which can scroll\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function scrollingController(container, dir) {\n        // If there is any scrollable area among parent elements and it can be manually scrolled, scroll the document\n        if (isScrollable(container, dir) && !isScrollBoundary(container, dir)) {\n            moveScroll(container, dir);\n            return true;\n        }\n\n        // If the spatnav container is document and it can be scrolled, scroll the document\n        if (!container.parentElement && !isHTMLScrollBoundary(container, dir)) {\n            moveScroll(container.ownerDocument.documentElement, dir);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Find the candidates within a spatial navigation container include delegable container.\n     * This function does not search inside delegable container or focusable container.\n     * In other words, this return candidates set is not included focusable elements inside delegable container or focusable container.\n     *\n     * @function getSpatialNavigationCandidates\n     * @param container {Node} - The spatial navigation container\n     * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.\n     *                                          Default value is 'visible'.\n     * @returns {sequence<Node>} candidate elements within the container\n     */\n    function getSpatialNavigationCandidates(container, option = { mode: 'visible' }) {\n        let candidates = [];\n\n        if (container.childElementCount > 0) {\n            if (!container.parentElement) {\n                container = container.getElementsByTagName('body')[0] || document.body;\n            }\n            const children = container.children;\n            for (const elem of children) {\n                if (isDelegableContainer(elem)) {\n                    candidates.push(elem);\n                } else if (isFocusable(elem)) {\n                    candidates.push(elem);\n\n                    if (!isContainer(elem) && elem.childElementCount) {\n                        candidates = candidates.concat(getSpatialNavigationCandidates(elem, { mode: 'all' }));\n                    }\n                } else if (elem.childElementCount) {\n                    candidates = candidates.concat(getSpatialNavigationCandidates(elem, { mode: 'all' }));\n                }\n            }\n        }\n\n        //   console.log(candidates)\n        return option.mode === 'all' ? candidates : candidates.filter(isVisible);\n    }\n\n    /**\n     * Find the candidates among focusable elements within a spatial navigation container from the search origin (currently focused element)\n     * depending on the directional information.\n     * @function getFilteredSpatialNavigationCandidates\n     * @param element {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation without the directional information\n     * @param container {Node} - The spatial navigation container\n     * @returns {Node} The candidates for spatial navigation considering the directional information\n     */\n    function getFilteredSpatialNavigationCandidates(element, dir, candidates, container) {\n        const targetElement = element;\n        // Removed below line due to a bug. (iframe body rect is sometime weird.)\n        // const targetElement = (element.nodeName === 'IFRAME') ? element.contentDocument.body : element;\n        // If the container is unknown, get the closest container from the element\n        container = container || targetElement.getSpatialNavigationContainer();\n\n        // If the candidates is unknown, find candidates\n        // 5-1\n        candidates = !candidates || candidates.length <= 0 ? getSpatialNavigationCandidates(container) : candidates;\n        return filteredCandidates(targetElement, candidates, dir, container);\n    }\n\n    /**\n     * Find the best candidate among the candidates within the container from the search origin (currently focused element)\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-spatialnavigationsearch}\n     * @function spatialNavigationSearch\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param container {Node} - The spatial navigation container\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function spatialNavigationSearch(dir, args) {\n        const targetElement = this;\n        let internalCandidates = [];\n        let externalCandidates = [];\n        let insideOverlappedCandidates = getOverlappedCandidates(targetElement);\n        let bestTarget;\n\n        // Set default parameter value\n        if (!args) args = {};\n\n        const defaultContainer = targetElement.getSpatialNavigationContainer();\n        let defaultCandidates = getSpatialNavigationCandidates(defaultContainer);\n        const container = args.container || defaultContainer;\n        if (args.container && defaultContainer.contains(args.container)) {\n            defaultCandidates = defaultCandidates.concat(getSpatialNavigationCandidates(container));\n        }\n        const candidates =\n            args.candidates && args.candidates.length > 0\n                ? args.candidates.filter((candidate) => container.contains(candidate))\n                : defaultCandidates.filter((candidate) => container.contains(candidate) && container !== candidate);\n\n        // Find the best candidate\n        // 5\n        // If startingPoint is either a scroll container or the document,\n        // find the best candidate within startingPoint\n        if (candidates && candidates.length > 0) {\n            // Divide internal or external candidates\n            candidates.forEach((candidate) => {\n                if (candidate !== targetElement) {\n                    (targetElement.contains(candidate) && targetElement !== candidate\n                            ? internalCandidates\n                            : externalCandidates\n                    ).push(candidate);\n                }\n            });\n\n            // include overlapped element to the internalCandidates\n            let fullyOverlapped = insideOverlappedCandidates.filter(\n                (candidate) => !internalCandidates.includes(candidate),\n            );\n            let overlappedContainer = candidates.filter(\n                (candidate) => isContainer(candidate) && isEntirelyVisible(targetElement, candidate),\n            );\n            let overlappedByParent = overlappedContainer\n                .map((elm) => elm.focusableAreas())\n                .flat()\n                .filter((candidate) => candidate !== targetElement);\n\n            internalCandidates = internalCandidates\n                .concat(fullyOverlapped)\n                .filter((candidate) => container.contains(candidate));\n            externalCandidates = externalCandidates\n                .concat(overlappedByParent)\n                .filter((candidate) => container.contains(candidate));\n\n            // Filter external Candidates\n            if (externalCandidates.length > 0) {\n                externalCandidates = getFilteredSpatialNavigationCandidates(\n                    targetElement,\n                    dir,\n                    externalCandidates,\n                    container,\n                );\n            }\n\n            // If there isn't search origin element but search orgin rect exist  (search origin isn't in the layout case)\n            if (searchOriginRect) {\n                bestTarget = selectBestCandidate(\n                    targetElement,\n                    getFilteredSpatialNavigationCandidates(targetElement, dir, internalCandidates, container),\n                    dir,\n                );\n            }\n\n            if (internalCandidates && internalCandidates.length > 0 && !(targetElement.nodeName === 'INPUT')) {\n                bestTarget = selectBestCandidateFromEdge(targetElement, internalCandidates, dir);\n            }\n\n            bestTarget = bestTarget || selectBestCandidate(targetElement, externalCandidates, dir);\n\n            if (bestTarget && isDelegableContainer(bestTarget)) {\n                // if best target is delegable container, then find descendants candidate inside delegable container.\n                const innerTarget = getSpatialNavigationCandidates(bestTarget, {\n                    mode: 'all',\n                });\n                const descendantsBest =\n                    innerTarget.length > 0\n                        ? targetElement.spatialNavigationSearch(dir, {\n                            candidates: innerTarget,\n                            container: bestTarget,\n                        })\n                        : null;\n                if (descendantsBest) {\n                    bestTarget = descendantsBest;\n                } else if (!isFocusable(bestTarget)) {\n                    // if there is no target inside bestTarget and delegable container is not focusable,\n                    // then try to find another best target without curren best target.\n                    candidates.splice(candidates.indexOf(bestTarget), 1);\n                    bestTarget = candidates.length\n                        ? targetElement.spatialNavigationSearch(dir, {\n                            candidates: candidates,\n                            container: container,\n                        })\n                        : null;\n                }\n            }\n            return bestTarget;\n        }\n\n        return null;\n    }\n\n    /**\n     * Get the filtered candidate among candidates.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}\n     * @function filteredCandidates\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param container {Node} - The spatial navigation container\n     * @returns {sequence<Node>} The filtered candidates which are not the search origin and not in the given spatial navigation direction from the search origin\n     */\n    // TODO: Need to fix filtering the candidates with more clean code\n    function filteredCandidates(currentElm, candidates, dir, container) {\n        const originalContainer = currentElm.getSpatialNavigationContainer();\n        let eventTargetRect;\n\n        // If D(dir) is null, let candidates be the same as visibles\n        if (dir === undefined) return candidates;\n\n        // Offscreen handling when originalContainer is not <HTML>\n        if (originalContainer.parentElement && container !== originalContainer && !isVisible(currentElm)) {\n            eventTargetRect = getBoundingClientRect(originalContainer);\n        } else {\n            eventTargetRect = searchOriginRect || getBoundingClientRect(currentElm);\n        }\n\n        /*\n         * Else, let candidates be the subset of the elements in visibles\n         * whose principal box’s geometric center is within the closed half plane\n         * whose boundary goes through the geometric center of starting point and is perpendicular to D.\n         */\n        if ((isContainer(currentElm) || currentElm.nodeName === 'BODY') && !(currentElm.nodeName === 'INPUT')) {\n            return candidates.filter((candidate) => {\n                const candidateRect = getBoundingClientRect(candidate);\n                return (\n                    container.contains(candidate) &&\n                    ((currentElm.contains(candidate) &&\n                        isInside(eventTargetRect, candidateRect) &&\n                        candidate !== currentElm) ||\n                        isOutside(candidateRect, eventTargetRect, dir))\n                );\n            });\n        } else {\n            return candidates.filter((candidate) => {\n                const candidateRect = getBoundingClientRect(candidate);\n                const candidateBody = candidate.nodeName === 'IFRAME' ? candidate.contentDocument.body : null;\n                return (\n                    container.contains(candidate) &&\n                    candidate !== currentElm &&\n                    candidateBody !== currentElm &&\n                    isOutside(candidateRect, eventTargetRect, dir) &&\n                    !isInside(eventTargetRect, candidateRect)\n                );\n            });\n        }\n    }\n\n    /**\n     * Select the best candidate among given candidates.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}\n     * @function selectBestCandidate\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function selectBestCandidate(currentElm, candidates, dir) {\n        const container = currentElm.getSpatialNavigationContainer();\n        const spatialNavigationFunction = getComputedStyle(container).getPropertyValue('--spatial-navigation-function');\n        const currentTargetRect = searchOriginRect || getBoundingClientRect(currentElm);\n        let distanceFunction;\n        let alignedCandidates;\n\n        switch (spatialNavigationFunction) {\n            case 'grid':\n                alignedCandidates = candidates.filter((elm) =>\n                    isAligned(currentTargetRect, getBoundingClientRect(elm), dir),\n                );\n                if (alignedCandidates.length > 0) {\n                    candidates = alignedCandidates;\n                }\n                distanceFunction = getAbsoluteDistance;\n                break;\n            default:\n                distanceFunction = getDistance;\n                break;\n        }\n        return getClosestElement(currentElm, candidates, dir, distanceFunction);\n    }\n\n    /**\n     * Select the best candidate among candidates by finding the closet candidate from the edge of the currently focused element (search origin).\n     * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate (Step 5)}\n     * @function selectBestCandidateFromEdge\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Node} The best candidate which will gain the focus\n     */\n    function selectBestCandidateFromEdge(currentElm, candidates, dir) {\n        if (startingPoint) return getClosestElement(currentElm, candidates, dir, getDistanceFromPoint);\n        else return getClosestElement(currentElm, candidates, dir, getInnerDistance);\n    }\n\n    /**\n     * Select the closest candidate from the currently focused element (search origin) among candidates by using the distance function.\n     * @function getClosestElement\n     * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n     * @param candidates {sequence<Node>} - The candidates for spatial navigation\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param distanceFunction {function} - The distance function which measures the distance from the search origin to each candidate\n     * @returns {Node} The candidate which is the closest one from the search origin\n     */\n    function getClosestElement(currentElm, candidates, dir, distanceFunction) {\n        let eventTargetRect = null;\n        if (\n            window.location !== window.parent.location &&\n            (currentElm.nodeName === 'BODY' || currentElm.nodeName === 'HTML')\n        ) {\n            // If the eventTarget is iframe, then get rect of it based on its containing document\n            // Set the iframe's position as (0,0) because the rects of elements inside the iframe don't know the real iframe's position.\n            eventTargetRect = window.frameElement.getBoundingClientRect();\n            eventTargetRect.x = 0;\n            eventTargetRect.y = 0;\n        } else {\n            eventTargetRect = searchOriginRect || currentElm.getBoundingClientRect();\n        }\n\n        let minDistance = Number.POSITIVE_INFINITY;\n        let minDistanceElements = [];\n\n        if (candidates) {\n            for (let i = 0; i < candidates.length; i++) {\n                const distance = distanceFunction(eventTargetRect, getBoundingClientRect(candidates[i]), dir);\n\n                // If the same distance, the candidate will be selected in the DOM order\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minDistanceElements = [candidates[i]];\n                } else if (distance === minDistance) {\n                    minDistanceElements.push(candidates[i]);\n                }\n            }\n        }\n        if (minDistanceElements.length === 0) return null;\n\n        return minDistanceElements.length > 1 && distanceFunction === getAbsoluteDistance\n            ? getClosestElement(currentElm, minDistanceElements, dir, getEuclideanDistance)\n            : minDistanceElements[0];\n    }\n\n    /**\n     * Get container of an element.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-getspatialnavigationcontainer}\n     * @module Element\n     * @function getSpatialNavigationContainer\n     * @returns {Node} The spatial navigation container\n     */\n    function getSpatialNavigationContainer() {\n        let container = this;\n\n        do {\n            if (!container.parentElement) {\n                if (window.location !== window.parent.location) {\n                    container = window.parent.document.documentElement;\n                } else {\n                    container = window.document.documentElement;\n                }\n                break;\n            } else {\n                container = container.parentElement;\n            }\n\n            // console.log(container, isContainer(container));\n        } while (!isContainer(container));\n        return container;\n    }\n\n    /**\n     * Get nearest scroll container of an element.\n     * @function getScrollContainer\n     * @param Element\n     * @returns {Node} The spatial navigation container\n     */\n    function getScrollContainer(element) {\n        let scrollContainer = element;\n\n        do {\n            if (!scrollContainer.parentElement) {\n                if (window.location !== window.parent.location) {\n                    scrollContainer = window.parent.document.documentElement;\n                } else {\n                    scrollContainer = window.document.documentElement;\n                }\n                break;\n            } else {\n                scrollContainer = scrollContainer.parentElement;\n            }\n        } while (!isScrollContainer(scrollContainer) || !isVisible(scrollContainer));\n\n        if (scrollContainer === document || scrollContainer === document.documentElement) {\n            scrollContainer = window;\n        }\n\n        return scrollContainer;\n    }\n\n    /**\n     * Find focusable elements within the spatial navigation container.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-focusableareas}\n     * @function focusableAreas\n     * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.\n     *                                          Default value is 'visible'.\n     * @returns {sequence<Node>} All focusable elements or only visible focusable elements within the container\n     */\n    function focusableAreas(option = { mode: 'visible' }) {\n        const container = this.parentElement ? this : document.body;\n        const focusables = Array.prototype.filter.call(container.getElementsByTagName('*'), isFocusable);\n        return option.mode === 'all' ? focusables : focusables.filter(isVisible);\n    }\n\n    /**\n     * Create the NavigationEvent: navbeforefocus, navnotarget\n     * @see {@link https://drafts.csswg.org/css-nav-1/#events-navigationevent}\n     * @function createSpatNavEvents\n     * @param option {string} - Type of the navigation event (beforefocus, notarget)\n     * @param element {Node} - The target element of the event\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function createSpatNavEvents(eventType, containerElement, currentElement, direction) {\n        if (['beforefocus', 'notarget'].includes(eventType)) {\n            const data = {\n                causedTarget: currentElement,\n                dir: direction,\n            };\n            const triggeredEvent = new CustomEvent('nav' + eventType, {\n                bubbles: true,\n                cancelable: true,\n                detail: data,\n            });\n            return containerElement.dispatchEvent(triggeredEvent);\n        }\n    }\n\n    /**\n     * Get the value of the CSS custom property of the element\n     * @function readCssVar\n     * @param element {Node}\n     * @param varName {string} - The name of the css custom property without '--'\n     * @returns {string} The value of the css custom property\n     */\n    function readCssVar(element, varName) {\n        return getComputedStyle(element).getPropertyValue(`--${varName}`).trim();\n    }\n\n    /**\n     * Decide whether or not the 'contain' value is given to 'spatial-navigation-contain' css property of an element\n     * @function isCSSSpatNavContain\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isCSSSpatNavContain(element) {\n        return readCssVar(element, 'spatial-navigation-contain') === 'contain';\n    }\n\n    /**\n     * Return the value of 'spatial-navigation-action' css property of an element\n     * @function getCSSSpatNavAction\n     * @param element {Node} - would be the spatial navigation container\n     * @returns {string} auto | focus | scroll\n     */\n    function getCSSSpatNavAction(element) {\n        return 'focus';\n        //   return readCssVar(element, 'spatial-navigation-action') || 'auto';\n    }\n\n    /**\n     * Only move the focus with spatial navigation. Manually scrolling isn't available.\n     * @function navigateChain\n     * @param eventTarget {Node} - currently focused element\n     * @param container {SpatialNavigationContainer} - container\n     * @param parentContainer {SpatialNavigationContainer} - parent container\n     * @param option - visible || all\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     */\n    function navigateChain(eventTarget, container, parentContainer, dir, option) {\n        let currentOption = {\n            candidates: getSpatialNavigationCandidates(container, { mode: option }),\n            container,\n        };\n        //   console.log(currentOption)\n\n        while (parentContainer) {\n            if (focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)) {\n                return;\n            } else {\n                if (option === 'visible' && scrollingController(container, dir)) return;\n                else {\n                    if (!createSpatNavEvents('notarget', container, eventTarget, dir)) return;\n\n                    // find the container\n                    if (container === document || container === document.documentElement) {\n                        if (window.location !== window.parent.location) {\n                            // The page is in an iframe. eventTarget needs to be reset because the position of the element in the iframe\n                            eventTarget = window.frameElement;\n                            container = eventTarget.ownerDocument.documentElement;\n                        }\n                    } else {\n                        container = parentContainer;\n                    }\n                    currentOption = {\n                        candidates: getSpatialNavigationCandidates(container, {\n                            mode: option,\n                        }),\n                        container,\n                    };\n                    let nextContainer = container.getSpatialNavigationContainer();\n\n                    if (nextContainer !== container) {\n                        parentContainer = nextContainer;\n                    } else {\n                        parentContainer = null;\n                    }\n                }\n            }\n        }\n\n        currentOption = {\n            candidates: getSpatialNavigationCandidates(container, { mode: option }),\n            container,\n        };\n\n        // Behavior after 'navnotarget' - Getting out from the current spatnav container\n        if (\n            !parentContainer &&\n            container &&\n            focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)\n        )\n            return;\n\n        if (!createSpatNavEvents('notarget', currentOption.container, eventTarget, dir)) return;\n\n        if (getCSSSpatNavAction(container) === 'auto' && option === 'visible') {\n            if (scrollingController(container, dir)) return;\n        }\n    }\n\n    /**\n     * Find search origin\n     * @see {@link https://drafts.csswg.org/css-nav-1/#nav}\n     * @function findSearchOrigin\n     * @returns {Node} The search origin for the spatial navigation\n     */\n    function findSearchOrigin() {\n        let searchOrigin = document.activeElement;\n\n        if (!searchOrigin || (searchOrigin === document.body && !document.querySelector(':focus'))) {\n            // When the previous search origin lost its focus by blur: (1) disable attribute (2) visibility: hidden\n            if (savedSearchOrigin.element && searchOrigin !== savedSearchOrigin.element) {\n                const elementStyle = window.getComputedStyle(savedSearchOrigin.element, null);\n                const invisibleStyle = ['hidden', 'collapse'];\n\n                if (\n                    savedSearchOrigin.element.disabled ||\n                    invisibleStyle.includes(elementStyle.getPropertyValue('visibility'))\n                ) {\n                    searchOrigin = savedSearchOrigin.element;\n                    return searchOrigin;\n                }\n            }\n            searchOrigin = document.documentElement;\n        }\n        // When the previous search origin lost its focus by blur: (1) display:none () element size turned into zero\n        if (\n            savedSearchOrigin.element &&\n            (getBoundingClientRect(savedSearchOrigin.element).height === 0 ||\n                getBoundingClientRect(savedSearchOrigin.element).width === 0)\n        ) {\n            (startingPoint = (savedSearchOrigin.left + savedSearchOrigin.right) / 2),\n            (savedSearchOrigin.top + savedSearchOrigin.bottom) / 2;\n            // searchOriginRect = savedSearchOrigin.rect;\n        }\n\n        if (!isVisibleInScroller(searchOrigin)) {\n            const scroller = getScrollContainer(searchOrigin);\n            if (scroller && (scroller === window || getCSSSpatNavAction(scroller) === 'auto')) return scroller;\n        }\n        return searchOrigin;\n    }\n\n    /**\n     * Move the scroll of an element depending on the given spatial navigation directrion\n     * (Assume that User Agent defined distance is '40px')\n     * @see {@link https://drafts.csswg.org/css-nav-1/#directionally-scroll-an-element}\n     * @function moveScroll\n     * @param element {Node} - The scrollable element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @param offset {Number} - The explicit amount of offset for scrolling. Default value is 0.\n     */\n    function moveScroll(element, dir, offset = 0) {\n        if (element) {\n            switch (dir) {\n                case 'left':\n                    element.scrollLeft -= 40 + offset;\n                    break;\n                case 'right':\n                    element.scrollLeft += 40 + offset;\n                    break;\n                case 'up':\n                    element.scrollTop -= 40 + offset;\n                    break;\n                case 'down':\n                    element.scrollTop += 40 + offset;\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Decide whether an element is container or not.\n     * @function isContainer\n     * @param element {Node} element\n     * @returns {boolean}\n     */\n    function isContainer(element) {\n        return (\n            !element.parentElement ||\n            element.nodeName === 'IFRAME' ||\n            isScrollContainer(element) ||\n            isCSSSpatNavContain(element)\n        );\n    }\n\n    /**\n     * Decide whether an element is delegable container or not.\n     * NOTE: THIS IS NON-NORMATIVE API.\n     * @function isDelegableContainer\n     * @param element {Node} element\n     * @returns {boolean}\n     */\n    function isDelegableContainer(element) {\n        return readCssVar(element, 'spatial-navigation-contain') === 'delegable';\n    }\n\n    /**\n     * Decide whether an element is a scrollable container or not.\n     * @see {@link https://drafts.csswg.org/css-overflow-3/#scroll-container}\n     * @function isScrollContainer\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isScrollContainer(element) {\n        const elementStyle = window.getComputedStyle(element, null);\n        const overflowX = elementStyle.getPropertyValue('overflow-x');\n        const overflowY = elementStyle.getPropertyValue('overflow-y');\n\n        return (overflowX !== 'visible' && overflowX !== 'clip' && isOverflow(element, 'left')) ||\n        (overflowY !== 'visible' && overflowY !== 'clip' && isOverflow(element, 'down'))\n            ? true\n            : false;\n    }\n\n    /**\n     * Decide whether this element is scrollable or not.\n     * NOTE: If the value of 'overflow' is given to either 'visible', 'clip', or 'hidden', the element isn't scrollable.\n     *       If the value is 'hidden', the element can be only programmically scrollable. (https://drafts.csswg.org/css-overflow-3/#valdef-overflow-hidden)\n     * @function isScrollable\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isScrollable(element, dir) {\n        // element, dir\n        if (element && typeof element === 'object') {\n            if (dir && typeof dir === 'string') {\n                // parameter: dir, element\n                if (isOverflow(element, dir)) {\n                    // style property\n                    const elementStyle = window.getComputedStyle(element, null);\n                    const overflowX = elementStyle.getPropertyValue('overflow-x');\n                    const overflowY = elementStyle.getPropertyValue('overflow-y');\n\n                    switch (dir) {\n                        case 'left':\n                        /* falls through */\n                        case 'right':\n                            return overflowX !== 'visible' && overflowX !== 'clip' && overflowX !== 'hidden';\n                        case 'up':\n                        /* falls through */\n                        case 'down':\n                            return overflowY !== 'visible' && overflowY !== 'clip' && overflowY !== 'hidden';\n                    }\n                }\n                return false;\n            } else {\n                // parameter: element\n                return (\n                    element.nodeName === 'HTML' ||\n                    element.nodeName === 'BODY' ||\n                    (isScrollContainer(element) && isOverflow(element))\n                );\n            }\n        }\n    }\n\n    /**\n     * Decide whether an element is overflow or not.\n     * @function isOverflow\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isOverflow(element, dir) {\n        if (element && typeof element === 'object') {\n            if (dir && typeof dir === 'string') {\n                // parameter: element, dir\n                switch (dir) {\n                    case 'left':\n                    /* falls through */\n                    case 'right':\n                        return element.scrollWidth > element.clientWidth;\n                    case 'up':\n                    /* falls through */\n                    case 'down':\n                        return element.scrollHeight > element.clientHeight;\n                }\n            } else {\n                // parameter: element\n                return element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Decide whether the scrollbar of the browsing context reaches to the end or not.\n     * @function isHTMLScrollBoundary\n     * @param element {Node} - The top browsing context\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isHTMLScrollBoundary(element, dir) {\n        let result = false;\n        switch (dir) {\n            case 'left':\n                result = element.scrollLeft === 0;\n                break;\n            case 'right':\n                result = element.scrollWidth - element.scrollLeft - element.clientWidth === 0;\n                break;\n            case 'up':\n                result = element.scrollTop === 0;\n                break;\n            case 'down':\n                result = element.scrollHeight - element.scrollTop - element.clientHeight === 0;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Decide whether the scrollbar of an element reaches to the end or not.\n     * @function isScrollBoundary\n     * @param element {Node}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isScrollBoundary(element, dir) {\n        if (isScrollable(element, dir)) {\n            const winScrollY = element.scrollTop;\n            const winScrollX = element.scrollLeft;\n\n            const height = element.scrollHeight - element.clientHeight;\n            const width = element.scrollWidth - element.clientWidth;\n\n            switch (dir) {\n                case 'left':\n                    return winScrollX === 0;\n                case 'right':\n                    return Math.abs(winScrollX - width) <= 1;\n                case 'up':\n                    return winScrollY === 0;\n                case 'down':\n                    return Math.abs(winScrollY - height) <= 1;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Decide whether an element is inside the scorller viewport or not\n     *\n     * @function isVisibleInScroller\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isVisibleInScroller(element) {\n        const elementRect = element.getBoundingClientRect();\n        let nearestScroller = getScrollContainer(element);\n\n        let scrollerRect = null;\n        if (nearestScroller !== window) {\n            scrollerRect = getBoundingClientRect(nearestScroller);\n        } else {\n            scrollerRect = new DOMRect(0, 0, window.innerWidth, window.innerHeight);\n        }\n\n        if (isInside(scrollerRect, elementRect, 'left') && isInside(scrollerRect, elementRect, 'down')) return true;\n        else return false;\n    }\n\n    /**\n     * Decide whether an element is focusable for spatial navigation.\n     * 1. If element is the browsing context (document, iframe), then it's focusable,\n     * 2. If the element is scrollable container (regardless of scrollable axis), then it's focusable,\n     * 3. The value of tabIndex >= 0, then it's focusable,\n     * 4. If the element is disabled, it isn't focusable,\n     * 5. If the element is expressly inert, it isn't focusable,\n     * 6. Whether the element is being rendered or not.\n     *\n     * @function isFocusable\n     * @param element {Node}\n     * @returns {boolean}\n     *\n     * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#focusable-area}\n     */\n    function isFocusable(element) {\n        if (\n            element.tabIndex < 0 ||\n            isAtagWithoutHref(element) ||\n            isActuallyDisabled(element) ||\n            isExpresslyInert(element) ||\n            !isBeingRendered(element)\n        )\n            return false;\n        else if (!element.parentElement || (isScrollable(element) && isOverflow(element)) || element.tabIndex >= 0)\n            return true;\n    }\n\n    /**\n     * Decide whether an element is a tag without href attribute or not.\n     *\n     * @function isAtagWithoutHref\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isAtagWithoutHref(element) {\n        return (\n            element.tagName === 'A' &&\n            element.getAttribute('href') === null &&\n            element.getAttribute('tabIndex') === null\n        );\n    }\n\n    /**\n     * Decide whether an element is actually disabled or not.\n     *\n     * @function isActuallyDisabled\n     * @param element {Node}\n     * @returns {boolean}\n     *\n     * @see {@link https://html.spec.whatwg.org/multipage/semantics-other.html#concept-element-disabled}\n     */\n    function isActuallyDisabled(element) {\n        if (['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(element.tagName))\n            return element.disabled;\n        else return false;\n    }\n\n    /**\n     * Decide whether the element is expressly inert or not.\n     * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#expressly-inert}\n     * @function isExpresslyInert\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isExpresslyInert(element) {\n        return element.inert && !element.ownerDocument.documentElement.inert;\n    }\n\n    /**\n     * Decide whether the element is being rendered or not.\n     * 1. If an element has the style as \"visibility: hidden | collapse\" or \"display: none\", it is not being rendered.\n     * 2. If an element has the style as \"opacity: 0\", it is not being rendered.(that is, invisible).\n     * 3. If width and height of an element are explicitly set to 0, it is not being rendered.\n     * 4. If a parent element is hidden, an element itself is not being rendered.\n     * (CSS visibility property and display property are inherited.)\n     * @see {@link https://html.spec.whatwg.org/multipage/rendering.html#being-rendered}\n     * @function isBeingRendered\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isBeingRendered(element) {\n        if (!isVisibleStyleProperty(element.parentElement)) return false;\n        if (\n            !isVisibleStyleProperty(element) ||\n            element.style.opacity === '0' ||\n            window.getComputedStyle(element).height === '0px' ||\n            window.getComputedStyle(element).width === '0px'\n        )\n            return false;\n        return true;\n    }\n\n    /**\n     * Decide whether this element is partially or completely visible to user agent.\n     * @function isVisible\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isVisible(element) {\n        return !element.parentElement || (isVisibleStyleProperty(element) && hitTest(element));\n    }\n\n    /**\n     * Decide whether this element is completely visible in this viewport for the arrow direction.\n     * @function isEntirelyVisible\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function isEntirelyVisible(element, container) {\n        const rect = getBoundingClientRect(element);\n        const containerElm = container || element.getSpatialNavigationContainer();\n        const containerRect = getBoundingClientRect(containerElm);\n\n        // FIXME: when element is bigger than container?\n        const entirelyVisible = !(\n            rect.left < containerRect.left ||\n            rect.right > containerRect.right ||\n            rect.top < containerRect.top ||\n            rect.bottom > containerRect.bottom\n        );\n\n        return entirelyVisible;\n    }\n\n    /**\n     * Decide the style property of this element is specified whether it's visible or not.\n     * @function isVisibleStyleProperty\n     * @param element {CSSStyleDeclaration}\n     * @returns {boolean}\n     */\n    function isVisibleStyleProperty(element) {\n        const elementStyle = window.getComputedStyle(element, null);\n        const thisVisibility = elementStyle.getPropertyValue('visibility');\n        const thisDisplay = elementStyle.getPropertyValue('display');\n        const invisibleStyle = ['hidden', 'collapse'];\n\n        return thisDisplay !== 'none' && !invisibleStyle.includes(thisVisibility);\n    }\n\n    /**\n     * Decide whether this element is entirely or partially visible within the viewport.\n     * @function hitTest\n     * @param element {Node}\n     * @returns {boolean}\n     */\n    function hitTest(element) {\n        const elementRect = getBoundingClientRect(element);\n        if (\n            element.nodeName !== 'IFRAME' &&\n            (elementRect.top < 0 ||\n                elementRect.left < 0 ||\n                elementRect.top > element.ownerDocument.documentElement.clientHeight ||\n                elementRect.left > element.ownerDocument.documentElement.clientWidth)\n        )\n            return false;\n\n        let offsetX = parseInt(element.offsetWidth) / 10;\n        let offsetY = parseInt(element.offsetHeight) / 10;\n\n        offsetX = isNaN(offsetX) ? 1 : offsetX;\n        offsetY = isNaN(offsetY) ? 1 : offsetY;\n\n        const hitTestPoint = {\n            // For performance, just using the three point(middle, leftTop, rightBottom) of the element for hit testing\n            middle: [(elementRect.left + elementRect.right) / 2, (elementRect.top + elementRect.bottom) / 2],\n            leftTop: [elementRect.left + offsetX, elementRect.top + offsetY],\n            rightBottom: [elementRect.right - offsetX, elementRect.bottom - offsetY],\n        };\n\n        for (const point in hitTestPoint) {\n            const elemFromPoint = element.ownerDocument.elementFromPoint(...hitTestPoint[point]);\n            if (element === elemFromPoint || element.contains(elemFromPoint)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Decide whether a child element is entirely or partially Included within container visually.\n     * @function isInside\n     * @param containerRect {DOMRect}\n     * @param childRect {DOMRect}\n     * @returns {boolean}\n     */\n    function isInside(containerRect, childRect) {\n        const rightEdgeCheck = containerRect.left < childRect.right && containerRect.right >= childRect.right;\n        const leftEdgeCheck = containerRect.left <= childRect.left && containerRect.right > childRect.left;\n        const topEdgeCheck = containerRect.top <= childRect.top && containerRect.bottom > childRect.top;\n        const bottomEdgeCheck = containerRect.top < childRect.bottom && containerRect.bottom >= childRect.bottom;\n        return (rightEdgeCheck || leftEdgeCheck) && (topEdgeCheck || bottomEdgeCheck);\n    }\n\n    /**\n     * Decide whether this element is entirely or partially visible within the viewport.\n     * Note: rect1 is outside of rect2 for the dir\n     * @function isOutside\n     * @param rect1 {DOMRect}\n     * @param rect2 {DOMRect}\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {boolean}\n     */\n    function isOutside(rect1, rect2, dir) {\n        switch (dir) {\n            case 'left':\n                return isRightSide(rect2, rect1);\n            case 'right':\n                return isRightSide(rect1, rect2);\n            case 'up':\n                return isBelow(rect2, rect1);\n            case 'down':\n                return isBelow(rect1, rect2);\n            default:\n                return false;\n        }\n    }\n\n    /* rect1 is right of rect2 */\n    function isRightSide(rect1, rect2) {\n        return (\n            rect1.left >= rect2.right ||\n            (rect1.left >= rect2.left &&\n                rect1.right > rect2.right &&\n                rect1.bottom > rect2.top &&\n                rect1.top < rect2.bottom)\n        );\n    }\n\n    /* rect1 is below of rect2 */\n    function isBelow(rect1, rect2) {\n        return (\n            rect1.top >= rect2.bottom ||\n            (rect1.top >= rect2.top &&\n                rect1.bottom > rect2.bottom &&\n                rect1.left < rect2.right &&\n                rect1.right > rect2.left)\n        );\n    }\n\n    /* rect1 is completely aligned or partially aligned for the direction */\n    function isAligned(rect1, rect2, dir) {\n        switch (dir) {\n            case 'left':\n            /* falls through */\n            case 'right':\n                return rect1.bottom > rect2.top && rect1.top < rect2.bottom;\n            case 'up':\n            /* falls through */\n            case 'down':\n                return rect1.right > rect2.left && rect1.left < rect2.right;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getDistanceFromPoint\n     * @param point {Point} - The search origin\n     * @param element {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The euclidian distance between the spatial navigation container and an element inside it\n     */\n    function getDistanceFromPoint(point, element, dir) {\n        point = startingPoint;\n        // Get exit point, entry point -> {x: '', y: ''};\n        const points = getEntryAndExitPoints(dir, point, element);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // The result is euclidian distance between P1 and P2.\n        return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n    }\n\n    /**\n     * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getInnerDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The euclidean distance between the spatial navigation container and an element inside it\n     */\n    function getInnerDistance(rect1, rect2, dir) {\n        const baseEdgeForEachDirection = {\n            left: 'right',\n            right: 'left',\n            up: 'bottom',\n            down: 'top',\n        };\n        const baseEdge = baseEdgeForEachDirection[dir];\n\n        return Math.abs(rect1[baseEdge] - rect2[baseEdge]);\n    }\n\n    /**\n     * Get the distance between the search origin and a candidate element considering the direction.\n     * @see {@link https://drafts.csswg.org/css-nav-1/#calculating-the-distance}\n     * @function getDistance\n     * @param searchOrigin {DOMRect | Point} - The search origin\n     * @param candidateRect {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getDistance(searchOrigin, candidateRect, dir) {\n        const kOrthogonalWeightForLeftRight = 30;\n        const kOrthogonalWeightForUpDown = 2;\n\n        let orthogonalBias = 0;\n        let alignBias = 0;\n        const alignWeight = 5.0;\n\n        // Get exit point, entry point -> {x: '', y: ''};\n        const points = getEntryAndExitPoints(dir, searchOrigin, candidateRect);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // A: The euclidean distance between P1 and P2.\n        const A = Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n        let B, C;\n\n        // B: The absolute distance in the direction which is orthogonal to dir between P1 and P2, or 0 if dir is null.\n        // C: The intersection edges between a candidate and the starting point.\n\n        // D: The square root of the area of intersection between the border boxes of candidate and starting point\n        const intersectionRect = getIntersectionRect(searchOrigin, candidateRect);\n        const D = intersectionRect.area;\n\n        switch (dir) {\n            case 'left':\n            /* falls through */\n            case 'right':\n                // If two elements are aligned, add align bias\n                // else, add orthogonal bias\n                if (isAligned(searchOrigin, candidateRect, dir))\n                    alignBias = Math.min(intersectionRect.height / searchOrigin.height, 1);\n                else orthogonalBias = searchOrigin.height / 2;\n\n                B = (P2 + orthogonalBias) * kOrthogonalWeightForLeftRight;\n                C = alignWeight * alignBias;\n                break;\n\n            case 'up':\n            /* falls through */\n            case 'down':\n                // If two elements are aligned, add align bias\n                // else, add orthogonal bias\n                if (isAligned(searchOrigin, candidateRect, dir))\n                    alignBias = Math.min(intersectionRect.width / searchOrigin.width, 1);\n                else orthogonalBias = searchOrigin.width / 2;\n\n                B = (P1 + orthogonalBias) * kOrthogonalWeightForUpDown;\n                C = alignWeight * alignBias;\n                break;\n\n            default:\n                B = 0;\n                C = 0;\n                break;\n        }\n\n        return A + B - C - D;\n    }\n\n    /**\n     * Get the euclidean distance between the search origin and a candidate element considering the direction.\n     * @function getEuclideanDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getEuclideanDistance(rect1, rect2, dir) {\n        // Get exit point, entry point\n        const points = getEntryAndExitPoints(dir, rect1, rect2);\n\n        // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n        // that minimize the distance between these two points\n        const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n        const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n        // Return the euclidean distance between P1 and P2.\n        return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n    }\n\n    /**\n     * Get the absolute distance between the search origin and a candidate element considering the direction.\n     * @function getAbsoluteDistance\n     * @param rect1 {DOMRect} - The search origin\n     * @param rect2 {DOMRect} - A candidate element\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n     * @returns {Number} The distance scoring between two elements\n     */\n    function getAbsoluteDistance(rect1, rect2, dir) {\n        // Get exit point, entry point\n        const points = getEntryAndExitPoints(dir, rect1, rect2);\n\n        // Return the absolute distance in the dir direction between P1 and P.\n        return dir === 'left' || dir === 'right'\n            ? Math.abs(points.entryPoint.x - points.exitPoint.x)\n            : Math.abs(points.entryPoint.y - points.exitPoint.y);\n    }\n\n    /**\n     * Get entry point and exit point of two elements considering the direction.\n     * @function getEntryAndExitPoints\n     * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD). Default value for dir is 'down'.\n     * @param searchOrigin {DOMRect | Point} - The search origin which contains the exit point\n     * @param candidateRect {DOMRect} - One of candidates which contains the entry point\n     * @returns {Points} The exit point from the search origin and the entry point from a candidate\n     */\n    function getEntryAndExitPoints(dir = 'down', searchOrigin, candidateRect) {\n        /**\n         * User type definition for Point\n         * @typeof {Object} Points\n         * @property {Point} Points.entryPoint\n         * @property {Point} Points.exitPoint\n         */\n        const points = { entryPoint: { x: 0, y: 0 }, exitPoint: { x: 0, y: 0 } };\n\n        if (startingPoint) {\n            points.exitPoint = searchOrigin;\n\n            switch (dir) {\n                case 'left':\n                    points.entryPoint.x = candidateRect.right;\n                    break;\n                case 'up':\n                    points.entryPoint.y = candidateRect.bottom;\n                    break;\n                case 'right':\n                    points.entryPoint.x = candidateRect.left;\n                    break;\n                case 'down':\n                    points.entryPoint.y = candidateRect.top;\n                    break;\n            }\n\n            // Set orthogonal direction\n            switch (dir) {\n                case 'left':\n                case 'right':\n                    if (startingPoint.y <= candidateRect.top) {\n                        points.entryPoint.y = candidateRect.top;\n                    } else if (startingPoint.y < candidateRect.bottom) {\n                        points.entryPoint.y = startingPoint.y;\n                    } else {\n                        points.entryPoint.y = candidateRect.bottom;\n                    }\n                    break;\n\n                case 'up':\n                case 'down':\n                    if (startingPoint.x <= candidateRect.left) {\n                        points.entryPoint.x = candidateRect.left;\n                    } else if (startingPoint.x < candidateRect.right) {\n                        points.entryPoint.x = startingPoint.x;\n                    } else {\n                        points.entryPoint.x = candidateRect.right;\n                    }\n                    break;\n            }\n        } else {\n            // Set direction\n            switch (dir) {\n                case 'left':\n                    points.exitPoint.x = searchOrigin.left;\n                    points.entryPoint.x =\n                        candidateRect.right < searchOrigin.left ? candidateRect.right : searchOrigin.left;\n                    break;\n                case 'up':\n                    points.exitPoint.y = searchOrigin.top;\n                    points.entryPoint.y =\n                        candidateRect.bottom < searchOrigin.top ? candidateRect.bottom : searchOrigin.top;\n                    break;\n                case 'right':\n                    points.exitPoint.x = searchOrigin.right;\n                    points.entryPoint.x =\n                        candidateRect.left > searchOrigin.right ? candidateRect.left : searchOrigin.right;\n                    break;\n                case 'down':\n                    points.exitPoint.y = searchOrigin.bottom;\n                    points.entryPoint.y =\n                        candidateRect.top > searchOrigin.bottom ? candidateRect.top : searchOrigin.bottom;\n                    break;\n            }\n\n            // Set orthogonal direction\n            switch (dir) {\n                case 'left':\n                case 'right':\n                    if (isBelow(searchOrigin, candidateRect)) {\n                        points.exitPoint.y = searchOrigin.top;\n                        points.entryPoint.y =\n                            candidateRect.bottom < searchOrigin.top ? candidateRect.bottom : searchOrigin.top;\n                    } else if (isBelow(candidateRect, searchOrigin)) {\n                        points.exitPoint.y = searchOrigin.bottom;\n                        points.entryPoint.y =\n                            candidateRect.top > searchOrigin.bottom ? candidateRect.top : searchOrigin.bottom;\n                    } else {\n                        points.exitPoint.y = Math.max(searchOrigin.top, candidateRect.top);\n                        points.entryPoint.y = points.exitPoint.y;\n                    }\n                    break;\n\n                case 'up':\n                case 'down':\n                    if (isRightSide(searchOrigin, candidateRect)) {\n                        points.exitPoint.x = searchOrigin.left;\n                        points.entryPoint.x =\n                            candidateRect.right < searchOrigin.left ? candidateRect.right : searchOrigin.left;\n                    } else if (isRightSide(candidateRect, searchOrigin)) {\n                        points.exitPoint.x = searchOrigin.right;\n                        points.entryPoint.x =\n                            candidateRect.left > searchOrigin.right ? candidateRect.left : searchOrigin.right;\n                    } else {\n                        points.exitPoint.x = Math.max(searchOrigin.left, candidateRect.left);\n                        points.entryPoint.x = points.exitPoint.x;\n                    }\n                    break;\n            }\n        }\n\n        return points;\n    }\n\n    /**\n     * Find focusable elements within the container\n     * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n     * @function getIntersectionRect\n     * @param rect1 {DOMRect} - The search origin which contains the exit point\n     * @param rect2 {DOMRect} - One of candidates which contains the entry point\n     * @returns {IntersectionArea} The intersection area between two elements.\n     *\n     * @typeof {Object} IntersectionArea\n     * @property {Number} IntersectionArea.width\n     * @property {Number} IntersectionArea.height\n     */\n    function getIntersectionRect(rect1, rect2) {\n        const intersection_rect = { width: 0, height: 0, area: 0 };\n\n        const new_location = [Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)];\n        const new_max_point = [Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom)];\n\n        intersection_rect.width = Math.abs(new_location[0] - new_max_point[0]);\n        intersection_rect.height = Math.abs(new_location[1] - new_max_point[1]);\n\n        if (!(new_location[0] >= new_max_point[0] || new_location[1] >= new_max_point[1])) {\n            // intersecting-cases\n            intersection_rect.area = Math.sqrt(intersection_rect.width * intersection_rect.height);\n        }\n\n        return intersection_rect;\n    }\n\n    /**\n     * Handle the spatial navigation behavior for HTMLInputElement, HTMLTextAreaElement\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input|HTMLInputElement (MDN)}\n     * @function handlingEditableElement\n     * @param e {Event} - keydownEvent\n     * @returns {boolean}\n     */\n    function handlingEditableElement(e) {\n        const SPINNABLE_INPUT_TYPES = ['email', 'date', 'month', 'number', 'time', 'week'],\n            TEXT_INPUT_TYPES = ['password', 'text', 'search', 'tel', 'url', null];\n        const eventTarget = document.activeElement;\n        const startPosition = eventTarget.selectionStart;\n        const endPosition = eventTarget.selectionEnd;\n        const focusNavigableArrowKey = {\n            left: false,\n            up: false,\n            right: false,\n            down: false,\n        };\n\n        const dir = ARROW_KEY_CODE[e.keyCode];\n        if (dir === undefined) {\n            return focusNavigableArrowKey;\n        }\n\n        if (SPINNABLE_INPUT_TYPES.includes(eventTarget.getAttribute('type')) && (dir === 'up' || dir === 'down')) {\n            focusNavigableArrowKey[dir] = true;\n        } else if (TEXT_INPUT_TYPES.includes(eventTarget.getAttribute('type')) || eventTarget.nodeName === 'TEXTAREA') {\n            if (startPosition === endPosition) {\n                // if there isn't any selected text\n                if (startPosition === 0) {\n                    focusNavigableArrowKey.left = true;\n                    focusNavigableArrowKey.up = true;\n                }\n                if (endPosition === eventTarget.value.length) {\n                    focusNavigableArrowKey.right = true;\n                    focusNavigableArrowKey.down = true;\n                }\n            }\n        } else {\n            // HTMLDataListElement, HTMLSelectElement, HTMLOptGroup\n            focusNavigableArrowKey[dir] = true;\n        }\n\n        return focusNavigableArrowKey;\n    }\n\n    /**\n     * Get the DOMRect of an element\n     * @function getBoundingClientRect\n     * @param {Node} element\n     * @returns {DOMRect}\n     */\n    function getBoundingClientRect(element) {\n        // memoization\n        let rect = mapOfBoundRect && mapOfBoundRect.get(element);\n        if (!rect) {\n            const boundingClientRect = element.getBoundingClientRect();\n            rect = {\n                top: Number(boundingClientRect.top.toFixed(2)),\n                right: Number(boundingClientRect.right.toFixed(2)),\n                bottom: Number(boundingClientRect.bottom.toFixed(2)),\n                left: Number(boundingClientRect.left.toFixed(2)),\n                width: Number(boundingClientRect.width.toFixed(2)),\n                height: Number(boundingClientRect.height.toFixed(2)),\n            };\n            mapOfBoundRect && mapOfBoundRect.set(element, rect);\n        }\n        return rect;\n    }\n\n    /**\n     * Get the candidates which is fully inside the target element in visual\n     * @param {Node} targetElement\n     * @returns {sequence<Node>}  overlappedCandidates\n     */\n    function getOverlappedCandidates(targetElement) {\n        const container = targetElement.getSpatialNavigationContainer();\n        const candidates = container.focusableAreas();\n        const overlappedCandidates = [];\n\n        candidates.forEach((element) => {\n            if (targetElement !== element && isEntirelyVisible(element, targetElement)) {\n                overlappedCandidates.push(element);\n            }\n        });\n\n        return overlappedCandidates;\n    }\n\n    /**\n     * Get the list of the experimental APIs\n     * @function getExperimentalAPI\n     */\n    function getExperimentalAPI() {\n        function canScroll(container, dir) {\n            return (\n                (isScrollable(container, dir) && !isScrollBoundary(container, dir)) ||\n                (!container.parentElement && !isHTMLScrollBoundary(container, dir))\n            );\n        }\n\n        function findTarget(findCandidate, element, dir, option) {\n            let eventTarget = element;\n            let bestNextTarget = null;\n\n            // 4\n            if (eventTarget === document || eventTarget === document.documentElement) {\n                eventTarget = document.body || document.documentElement;\n            }\n\n            // 5\n            // At this point, spatialNavigationSearch can be applied.\n            // If startingPoint is either a scroll container or the document,\n            // find the best candidate within startingPoint\n            if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {\n                if (eventTarget.nodeName === 'IFRAME') eventTarget = eventTarget.contentDocument.body;\n\n                const candidates = getSpatialNavigationCandidates(eventTarget, option);\n\n                // 5-2\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    return findCandidate\n                        ? getFilteredSpatialNavigationCandidates(eventTarget, dir, candidates)\n                        : eventTarget.spatialNavigationSearch(dir, { candidates });\n                }\n                if (canScroll(eventTarget, dir)) {\n                    return findCandidate ? [] : eventTarget;\n                }\n            }\n\n            // 6\n            // Let container be the nearest ancestor of eventTarget\n            let container = eventTarget.getSpatialNavigationContainer();\n            let parentContainer = container.parentElement ? container.getSpatialNavigationContainer() : null;\n\n            // When the container is the viewport of a browsing context\n            if (!parentContainer && window.location !== window.parent.location) {\n                parentContainer = window.parent.document.documentElement;\n            }\n\n            // 7\n            while (parentContainer) {\n                const candidates = filteredCandidates(\n                    eventTarget,\n                    getSpatialNavigationCandidates(container, option),\n                    dir,\n                    container,\n                );\n\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    bestNextTarget = eventTarget.spatialNavigationSearch(dir, {\n                        candidates,\n                        container,\n                    });\n                    if (bestNextTarget) {\n                        return findCandidate ? candidates : bestNextTarget;\n                    }\n                }\n\n                    // If there isn't any candidate and the best candidate among candidate:\n                    // 1) Scroll or 2) Find candidates of the ancestor container\n                // 8 - if\n                else if (canScroll(container, dir)) {\n                    return findCandidate ? [] : eventTarget;\n                } else if (container === document || container === document.documentElement) {\n                    container = window.document.documentElement;\n\n                    // The page is in an iframe\n                    if (window.location !== window.parent.location) {\n                        // eventTarget needs to be reset because the position of the element in the IFRAME\n                        // is unuseful when the focus moves out of the iframe\n                        eventTarget = window.frameElement;\n                        container = window.parent.document.documentElement;\n                        if (container.parentElement) parentContainer = container.getSpatialNavigationContainer();\n                        else {\n                            parentContainer = null;\n                            break;\n                        }\n                    }\n                } else {\n                    // avoiding when spatnav container with tabindex=-1\n                    if (isFocusable(container)) {\n                        eventTarget = container;\n                    }\n\n                    container = parentContainer;\n                    if (container.parentElement) parentContainer = container.getSpatialNavigationContainer();\n                    else {\n                        parentContainer = null;\n                        break;\n                    }\n                }\n            }\n\n            if (!parentContainer && container) {\n                // Getting out from the current spatnav container\n                const candidates = filteredCandidates(\n                    eventTarget,\n                    getSpatialNavigationCandidates(container, option),\n                    dir,\n                    container,\n                );\n\n                // 9\n                if (Array.isArray(candidates) && candidates.length > 0) {\n                    bestNextTarget = eventTarget.spatialNavigationSearch(dir, {\n                        candidates,\n                        container,\n                    });\n                    if (bestNextTarget) {\n                        return findCandidate ? candidates : bestNextTarget;\n                    }\n                }\n            }\n\n            if (canScroll(container, dir)) {\n                bestNextTarget = eventTarget;\n                return bestNextTarget;\n            }\n        }\n\n        return {\n            isContainer,\n            isScrollContainer,\n            isVisibleInScroller,\n            findCandidates: findTarget.bind(null, true),\n            findNextTarget: findTarget.bind(null, false),\n            getDistanceFromTarget: (element, candidateElement, dir) => {\n                if ((isContainer(element) || element.nodeName === 'BODY') && !(element.nodeName === 'INPUT')) {\n                    if (getSpatialNavigationCandidates(element).includes(candidateElement)) {\n                        return getInnerDistance(\n                            getBoundingClientRect(element),\n                            getBoundingClientRect(candidateElement),\n                            dir,\n                        );\n                    }\n                }\n                return getDistance(getBoundingClientRect(element), getBoundingClientRect(candidateElement), dir);\n            },\n        };\n    }\n\n    /**\n     * Makes to use the experimental APIs.\n     * @function enableExperimentalAPIs\n     * @param option {boolean} - If it is true, the experimental APIs can be used or it cannot.\n     */\n    function enableExperimentalAPIs(option) {\n        const currentKeyMode = window.__spatialNavigation__ && window.__spatialNavigation__.keyMode;\n        window.__spatialNavigation__ =\n            option === false ? getInitialAPIs() : Object.assign(getInitialAPIs(), getExperimentalAPI());\n        window.__spatialNavigation__.keyMode = currentKeyMode;\n        Object.seal(window.__spatialNavigation__);\n    }\n\n    /**\n     * Set the environment for using the spatial navigation polyfill.\n     * @function getInitialAPIs\n     */\n    function getInitialAPIs() {\n        return {\n            enableExperimentalAPIs,\n            get keyMode() {\n                return this._keymode ? this._keymode : 'ARROW';\n            },\n            set keyMode(mode) {\n                this._keymode = ['SHIFTARROW', 'ARROW', 'NONE'].includes(mode) ? mode : 'ARROW';\n            },\n            setStartingPoint: function (x, y) {\n                startingPoint = x && y ? { x, y } : null;\n            },\n        };\n    }\n\n    initiateSpatialNavigation();\n    enableExperimentalAPIs(true);\n\n    window.addEventListener('load', () => {\n        spatialNavigationHandler();\n    });\n})();\n\nlet currentSpatialNavigationContainer = null;\n\ndocument.addEventListener('navbeforefocus', (e) => {\n    if (e.target instanceof HTMLElement) {\n        e.preventDefault();\n\n        let { target } = e;\n\n        // focus on the first element when changing spatnav container\n        const nextSpatialNavigationContainer = target.getSpatialNavigationContainer();\n\n        if (currentSpatialNavigationContainer && currentSpatialNavigationContainer !== nextSpatialNavigationContainer) {\n            if (nextSpatialNavigationContainer.__lastElementFocused) {\n                target = nextSpatialNavigationContainer.__lastElementFocused;\n            } else {\n                [target] = nextSpatialNavigationContainer.focusableAreas({ mode: 'all' });\n            }\n            // target.focus();\n        }\n\n        currentSpatialNavigationContainer = nextSpatialNavigationContainer;\n        currentSpatialNavigationContainer.__lastElementFocused = target;\n\n        requestAnimationFrame(async () => {\n            target.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });\n            // if (isElementInViewport(target)) {\n            //     target.focus();\n            // }\n\n            await new Promise((resolve) => {\n                const intersectionObserver = new IntersectionObserver(\n                    ([entry]) => {\n                        if (entry.isIntersecting) {\n                            resolve();\n                        }\n                    },\n                    {\n                        threshold: 1,\n                    },\n                );\n                intersectionObserver.observe(target);\n            });\n\n            target.focus();\n        });\n    }\n});\n\ndocument.addEventListener('keyup', (event) => {\n    if (event.keyCode === 13) {\n        event.preventDefault();\n        if (document.activeElement && !(document.activeElement instanceof HTMLButtonElement)) {\n            document.activeElement.click();\n        }\n    }\n});\n\n// console.log('1');\n\n// let isIntersecting = false;\n// const intersectionObserver = new IntersectionObserver(([entry]) => {\n// console.log('2');\n//   isIntersecting = entry.isIntersecting;\n// }, {\n//   threshold: 1\n// });\n// intersectionObserver.observe($0)\n// console.log('3');\n\n// start observing\n// intersectionObserver.observe());\n\nfunction isElementInViewport(el) {\n    const rect = el.getBoundingClientRect();\n    return (\n        rect.top >= 0 &&\n        rect.left >= 0 &&\n        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n        rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n    );\n}\n","import { createHashHistory } from 'history';\n\nexport default createHashHistory();\n","import { types, applySnapshot, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';\n\nconst User = types\n    .model('User', {\n        address: types.maybeNull(types.string),\n        location: types.maybeNull(types.string),\n        phoneNumber: types.maybeNull(types.string),\n        name: types.maybeNull(types.string),\n    })\n    .actions((self) => ({\n        updateUser: (user: Record<string, string>) => {\n            applySnapshot(self, { ...self, ...user });\n        },\n    }));\n\nexport default User;\n\nexport type UserSnapshotOut = SnapshotOut<typeof User>;\nexport type UserSnapshotIn = SnapshotIn<typeof User>;\nexport type UserModel = Instance<typeof User>;\n","import { types, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';\nimport history from 'tools/history';\n\nexport const SEARCH = 'SEARCH';\nexport const CATALOG = 'CATALOG';\nexport const CART = 'CART';\nexport const ADDRESS_SIMPLE = 'ADDRESS_SIMPLE';\nexport const STATUS = 'STATUS';\nexport const PROMO = 'PROMO';\nexport const NO_AREA = 'NO_AREA';\nexport const SCREEN_SAVER = 'SCREEN_SAVER';\n\nexport const routes = {\n    [SEARCH]: '/search',\n    [CATALOG]: '/catalog',\n    [CART]: '/cart',\n    [ADDRESS_SIMPLE]: '/address-simple',\n    [STATUS]: '/status',\n    [PROMO]: '/promo',\n    [NO_AREA]: '/no-area',\n    [SCREEN_SAVER]: '/screen-saver',\n};\n\nconst Ui = types\n    .model('Ui', {\n        page: types.optional(types.enumeration(Object.values(routes)), routes.SCREEN_SAVER),\n        previous: types.maybeNull(types.enumeration(Object.values(routes))),\n    })\n    .actions((self) => {\n        const ui = self;\n\n        const gotoPage = (to: string) => {\n            ui.previous = ui.page;\n            ui.page = to;\n            history.push(to);\n        };\n\n        const goToCart = () => {\n            gotoPage(routes.CART);\n\n            window.AssistantClient.sendData({\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                action_id: 'GO_TO_CART',\n            });\n        };\n\n        return {\n            gotoPage,\n            goToCart,\n        };\n    });\n\nexport type UiModel = Instance<typeof Ui>;\nexport type UiSnapshotOut = SnapshotOut<typeof Ui>;\nexport type UiSnapshotIn = SnapshotIn<typeof Ui>;\n\nexport default Ui;\n","import { types, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';\n\nconst ProductItem = types.model('Product', {\n    id: types.identifier,\n    name: types.string,\n    clearName: types.string,\n    price: types.number,\n    imagesUrls: types.array(types.string),\n    quantityLeft: types.string,\n});\n\nexport default ProductItem;\n\nexport type ProductItemSnapshotOut = SnapshotOut<typeof ProductItem>;\nexport type ProductItemSnapshotIn = SnapshotIn<typeof ProductItem>;\nexport type ProductItemModel = Instance<typeof ProductItem>;\n","import { types, Instance, SnapshotIn, SnapshotOut } from 'mobx-state-tree';\n\nimport ProductItem from './product';\n\nconst Products = types.model('Products', {\n    title: types.optional(types.string, ''),\n    items: types.array(ProductItem),\n    selectedId: types.maybeNull(types.string),\n});\n\nexport default Products;\n\nexport type ProductsModel = Instance<typeof Products>;\nexport type ProductsSnapshotOut = SnapshotOut<typeof Products>;\nexport type ProductsSnapshotIn = SnapshotIn<typeof Products>;\n","import { types, Instance, SnapshotIn, cast, SnapshotOut } from 'mobx-state-tree';\n\nimport ProductItem from './product';\n\nconst CartItem = types.model('CartItem', {\n    product: types.reference(ProductItem),\n    count: types.number,\n});\n\nexport type CartItemModel = Instance<typeof CartItem>;\n\nconst Cart = types\n    .model('Cart', {\n        items: types.array(CartItem),\n        orderId: types.maybeNull(types.string),\n    })\n    .views((self) => ({\n        get count(): number {\n            return self.items.reduce((acc: number, item: CartItemModel) => acc + item.count, 0);\n        },\n\n        get totalPrice(): number {\n            return self.items.reduce(\n                (acc: number, item: CartItemModel) => acc + Math.floor(item.product.price * item.count) / 100,\n                0,\n            );\n        },\n\n        get itemsMap(): { [key: string]: CartItemModel } {\n            return self.items.reduce((acc: Record<string, CartItemModel>, item: CartItemModel) => {\n                acc[item.product.id] = item;\n\n                return acc;\n            }, {});\n        },\n    }))\n    .actions((self) => {\n        const cart = self;\n\n        const addToCart = (itemId: string, count = 1) => {\n            const item = cart.items.find((item) => item.product.id === itemId);\n\n            if (item) {\n                item.count = Math.min(Number(item.product.quantityLeft), item.count + count);\n            } else {\n                cart.items.push({\n                    product: itemId,\n                    count,\n                });\n            }\n        };\n\n        const clear = (): void => {\n            cart.items = cast([]);\n        };\n\n        interface RemoveFromCartParams {\n            itemId: string;\n            count: number;\n            shouldRemoveMention?: boolean;\n        }\n\n        const removeFromCart = ({ itemId, count, shouldRemoveMention }: RemoveFromCartParams) => {\n            const index = cart.items.findIndex((item: CartItemModel) => item.product.id === itemId);\n            const item = cart.items[index];\n\n            if (!item) {\n                return;\n            }\n\n            item.count = Math.max(0, item.count - count);\n\n            if (!item.count && shouldRemoveMention) {\n                cart.items.splice(index, 1);\n            }\n        };\n\n        const makePurchase = () => {\n            window.AssistantClient.sendData({\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                action_id: 'MAKE_PURCHASE',\n            });\n\n            if (process.env.REACT_APP_ENVIRONMENT === 'development') {\n                window.AssistantClient.onData({\n                    type: 'smart_app_data',\n                    // eslint-disable-next-line @typescript-eslint/camelcase\n                    smart_app_data: {\n                        command: 'VALIDATION_OK',\n                        status: true,\n                        orderId: '364528',\n                    },\n                });\n            }\n        };\n\n        return {\n            clear,\n            addToCart,\n            removeFromCart,\n            makePurchase,\n        };\n    });\n\nexport type CartModel = Instance<typeof Cart>;\nexport type CartSnapshotOut = SnapshotOut<typeof Cart>;\nexport type CartSnapshotIn = SnapshotIn<typeof Cart>;\n\nexport default Cart;\n","import { applySnapshot } from 'mobx-state-tree';\n\nimport { StoreType } from './types';\nimport { routes } from './ui';\nimport { ProductsSnapshotIn } from './products';\nimport { ProductItemModel } from './product';\n\ninterface VpsStockItem {\n    name: string;\n    clear_name: string; // eslint-disable-line camelcase\n    guid: string;\n    price: string;\n    images_urls: string[]; // eslint-disable-line camelcase\n    quantity_left: string; // eslint-disable-line camelcase\n}\n\ninterface AddItemsCommand {\n    stock: VpsStockItem[];\n}\n\nconst showItemsCast = (store: StoreType, command: AddItemsCommand): void => {\n    const stock = Object.values(command.stock);\n    const items: ProductItemModel[] = stock.map((item: VpsStockItem) => ({\n        id: item.guid,\n        name: item.name,\n        clearName: item.clear_name,\n        price: Number(item.price),\n        imagesUrls: item.images_urls as ProductItemModel['imagesUrls'],\n        quantityLeft: item.quantity_left,\n    }));\n\n    const snapshot: ProductsSnapshotIn = {\n        title: 'Попкорн',\n        items,\n    };\n\n    applySnapshot(store.products, snapshot);\n};\n\ninterface VpsAddItem extends AssistantSdkCommand {\n    item: string;\n    count: string;\n}\n\nconst addItemCast = (store: StoreType, command: VpsAddItem): void => {\n    const { item: itemId, count } = command;\n\n    store.cart.addToCart(itemId, Number(count));\n};\n\ninterface RemoveItemFromCartCommand extends AssistantSdkCommand {\n    item: string;\n    count: string;\n}\n\nconst removeItem = (store: StoreType, { item, count }: RemoveItemFromCartCommand) =>\n    store.cart.removeFromCart({ itemId: item, count: Number(count), shouldRemoveMention: true });\n\nconst removeAll = (store: StoreType) => store.cart.clear();\n\nconst goTo = (page: string) => (store: StoreType) => store.ui.gotoPage(page);\n\ninterface GotoCatalogCommand extends AssistantSdkCommand {\n    clear: boolean;\n    address_string: string;\n}\n\nconst gotoCatalog = (store: StoreType, command: GotoCatalogCommand): void => {\n    if (command.clear) {\n        store.cart.clear();\n    }\n\n    store.user.address = command.address_string;\n\n    store.ui.gotoPage(routes.CATALOG);\n};\n\ninterface ValidationOkCommand extends AssistantSdkCommand {\n    orderId: string; // eslint-disable-line camelcase\n}\n\nconst success = (store: StoreType, command: ValidationOkCommand) => {\n    store.cart.orderId = command.orderId;\n    store.ui.gotoPage(routes.STATUS);\n};\n\nconst casts: { [key: string]: Function } = {\n    SHOW_ITEMS: showItemsCast,\n    ADD_ITEM: addItemCast,\n    REMOVE_ITEM: removeItem,\n    REMOVE_ALL: removeAll,\n    GO_TO_VALIDATION: goTo(routes.CART),\n    GO_TO_NO_AREA: goTo(routes.NO_AREA),\n    GO_TO_ADDRESS_SIMPLE: goTo(routes.PROMO),\n    GO_TO_CATALOG: gotoCatalog,\n    VALIDATION_OK: success,\n};\n\nexport default casts;\n","import { types } from 'mobx-state-tree';\nimport { USER_MOCK } from 'mocks';\n\nimport user from './user';\nimport ui, { routes } from './ui';\nimport products from './products';\nimport cart from './cart';\nimport { StoreType } from './types';\nimport casts from './casts';\n\nconst Store = types\n    .model('Store', {\n        ui: types.optional(ui, {}),\n        products: types.optional(products, {}),\n        cart: types.optional(cart, {}),\n        user: types.optional(user, {}),\n    })\n    .actions((self) => {\n        const store = self;\n\n        const afterCreate = function init() {\n            if (window.AssistantHost && typeof window.AssistantHost.ready === 'function') {\n                console.log('call ready native method');\n                window.AssistantHost.ready();\n            }\n\n            if (process.env.REACT_APP_ENVIRONMENT === 'development') {\n                setTimeout(() => {\n                    window.AssistantClient.onData({\n                        type: 'smart_app_data',\n                        // eslint-disable-next-line @typescript-eslint/camelcase\n                        smart_app_data: {\n                            command: 'GO_TO_CATALOG',\n                            // eslint-disable-next-line @typescript-eslint/camelcase\n                            address_string: USER_MOCK.address,\n                        },\n                    });\n                }, 0);\n            }\n        };\n\n        const onMessage = (message: AssistantSdkCommand): void => {\n            const { command } = message.smart_app_data;\n\n            if (command in casts) {\n                const castFn = casts[command];\n\n                castFn(store, message.smart_app_data);\n            }\n        };\n\n        return { onMessage, afterCreate };\n    });\n\nconst store = Store.create({});\n\n// eslint-disable-next-line no-underscore-dangle\nwindow.__store = store;\n\nfunction castFromStore(store: StoreType): AppStateInterface {\n    return {\n        currentScreen: store.ui.page === routes.CATALOG ? 'catalog' : 'cart', // eslint-disable-line\n        foodtech: {\n            products: Object.keys(store.cart.itemsMap).map((itemId) => ({\n                id: itemId,\n                quantity: store.cart.itemsMap[itemId].count,\n            })),\n            totalPrice: {\n                value: store.cart.totalPrice,\n                discountValue: 0,\n            },\n            address: {\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                address_string: store.user.address || undefined,\n            },\n        },\n    };\n}\n\nwindow.AssistantClient = window.AssistantClient || {};\n// eslint-disable-next-line no-underscore-dangle\nwindow.__inbox = window.__inbox || [];\n// eslint-disable-next-line no-underscore-dangle\nwindow.__outbox = window.__outbox || [];\n\n/**\n * Assistand SDK API implementation:\n */\nwindow.AssistantClient.onStart = function AssistantSdkOnStart() {\n    console.log('invoke onStart callback');\n};\n\nwindow.AssistantClient.onData = function AssistantSdkOnMessage(command: AssistantSdkCommand): void {\n    // eslint-disable-next-line no-underscore-dangle\n    window.__inbox.push(command);\n    console.log('server message', command);\n    store.onMessage(command);\n};\n\nwindow.AssistantClient.sendData = function AssistantSdkSendMessage(message: any): void {\n    // eslint-disable-next-line no-underscore-dangle\n    window.__outbox.push({ message, store: castFromStore(store) });\n\n    console.log('sendData', message);\n\n    if (window.AssistantHost && typeof window.AssistantHost.sendData === 'function') {\n        window.AssistantHost.sendData(JSON.stringify(message), null);\n    }\n};\n\nwindow.AssistantClient.onRequestState = function AssistantSdkOnRequestState(): void {\n    console.log('invoke request state callback');\n    const state = castFromStore(store);\n\n    if (window.AssistantHost && typeof window.AssistantHost.updateState === 'function') {\n        window.AssistantHost.updateState(JSON.stringify(state));\n    }\n};\n\nexport default store;\n","import { useObserver } from 'mobx-react-lite';\n\nimport { StoreType } from '../stores/types';\n\nlet store: StoreType | null = null;\n\nexport const setStore = (newStore: StoreType): void => {\n    store = newStore;\n};\n\ntype PropsType = Record<string, any>;\n\nconst connect = (selector: Function) => (\n    baseComponent: React.FC<StoreType & PropsType>,\n): React.FC<StoreType & PropsType> => {\n    /* eslint-disable */\n    const component = (ownProps: PropsType) => {\n        if (store === null) throw new Error('Please, use setStore before your ReactDOM.render call');\n        return useObserver(() => {\n            return baseComponent({ ...ownProps, ...selector(store, ownProps) });\n        });\n    };\n    /* eslint-enable */\n    component.displayName = baseComponent.name;\n    return component;\n};\n\nexport default connect;\nexport const getStore = (): StoreType | null => store;\n\nexport const connectToStore = (component: React.FC<StoreType & any>): React.FC<StoreType & any> =>\n    connect((storeData: StoreType): StoreType => storeData)(component);\n","import packageJSON from '../../package.json';\n\nconst PREFIX = packageJSON.cssPrefix;\n\ninterface ConfitionsInterface<T> {\n    T?: boolean;\n}\n\nexport default (blockName: string, delimeter = '__', modDelimeter = '_'): BemRenderer => {\n    function renderer(...elements: string[]): string {\n        if (!elements.length) {\n            return PREFIX + blockName;\n        }\n\n        return elements.map((element) => PREFIX + blockName + delimeter + element).join(' ');\n    }\n\n    renderer.elem = (element: string, mod: string, modVal?: string): string =>\n        PREFIX + blockName + delimeter + element + modDelimeter + mod + (modVal ? modDelimeter + modVal : '');\n\n    renderer.mod = (mod: string, modVal?: string): string =>\n        PREFIX + blockName + modDelimeter + mod + (modVal ? modDelimeter + modVal : '');\n\n    renderer.modify = (conditions: ConfitionsInterface<string> = {}, elem?: string): string => {\n        const elemToModify = elem ? blockName + delimeter + elem : blockName;\n\n        return [\n            PREFIX,\n            elemToModify,\n            ' ',\n            Object.entries(conditions)\n                .map(([mod, predicate]) => Boolean(predicate) && PREFIX + elemToModify + modDelimeter + mod)\n                .filter(Boolean)\n                .join(' '),\n        ].join('');\n    };\n\n    renderer.all = (...values: string[]): string => values.join(' ');\n\n    return renderer;\n};\n","import React from 'react';\nimport Bem from 'tools/bem';\n\nexport default (Component: React.FC<any>, componentName?: string) => (props?: any, context?: any) => (\n    <Component {...props} context={context} bem={Bem(componentName || Component.name)} />\n);\n","import React from 'react';\nimport { StoreType } from 'stores/types';\nimport withBem from 'hoc/withBem';\nimport { connectToStore } from 'tools/connect';\n\nimport './Header.scss';\n\ninterface HeaderProps extends BemProps, StoreType {\n    className?: string;\n    title: string;\n}\n\nconst Component: React.FC<HeaderProps> = ({ bem, ui, title, children, className }) => (\n    <div className={bem.all(bem(), className || '')}>\n        {ui.previous ? <span className={bem('back')} /> : ''}\n        <div className={bem('section')}>\n            <div className={bem('logo')} />\n            <div className={bem('title')}>{title}</div>\n        </div>\n        <div className={bem('section')}>{children}</div>\n    </div>\n);\n\nexport const Header = connectToStore(withBem(Component, 'Header'));\n","import React from 'react';\nimport { connectToStore } from 'tools/connect';\nimport { StoreType } from 'stores/types';\nimport withBem from 'hoc/withBem';\nimport { routes } from 'stores/ui';\n\nimport './HeaderAddress.scss';\n\ninterface HeaderAddressProps extends StoreType, BemProps {}\n\nconst Component: React.FC<HeaderAddressProps> = ({ user, ui, bem }) => (\n    <div className={bem()} tabIndex={0} onClick={() => ui.gotoPage(routes.ADDRESS_SIMPLE)}>\n        <div className={bem('icon')} />\n        <div className={bem('text')}>{user.address}</div>\n    </div>\n);\n\nexport const HeaderAddress = withBem(connectToStore(Component), 'HeaderAddress');\n","export const splitByThousands = (data: string) =>\n    data.split('').reduceRight((acc, item, index, arr) => {\n        const indexFromEnd = index - (arr.length - 1);\n\n        if (indexFromEnd % 3 === 0) {\n            acc = ` ${acc}`;\n        }\n\n        return item + acc;\n    }, '');\n","import React from 'react';\nimport { connectToStore } from 'tools/connect';\nimport { StoreType } from 'stores/types';\nimport withBem from 'hoc/withBem';\nimport { splitByThousands } from 'tools';\n\nimport './HeaderCart.scss';\n\ninterface HeaderCartProps extends StoreType, BemProps {}\n\nconst Component: React.FC<HeaderCartProps> = ({ cart, ui, bem }) => (\n    <div className={bem()} tabIndex={0} onClick={() => ui.goToCart()}>\n        <div className={bem('icon')}>{cart.count > 0 && <span className={bem('badge')}>{cart.count}</span>}</div>\n        <div className={bem('price')}>{splitByThousands(String(cart.totalPrice))} ₽</div>\n    </div>\n);\n\nexport const HeaderCart = withBem(connectToStore(Component), 'HeaderCart');\n","import React from 'react';\n\nexport function useFocusOnMount<T>() {\n    const ref = React.useRef<T>(null);\n\n    React.useLayoutEffect(() => {\n        if (ref.current instanceof HTMLElement) {\n            ref.current.focus();\n        }\n    }, []);\n\n    return ref;\n}\n","import React from 'react';\nimport withBem from 'hoc/withBem';\nimport { ProductItemModel } from 'stores/product';\n\nimport './CatalogListItem.scss';\n\ninterface CatalogListItemProps extends ProductItemModel, BemProps {\n    mountRef?: React.RefObject<HTMLDivElement>;\n    index: number;\n    countInCart: number;\n    onClick: () => void;\n}\n\nconst Component: React.FC<CatalogListItemProps> = ({\n    bem,\n    imagesUrls,\n    countInCart,\n    name,\n    price,\n    index,\n    quantityLeft,\n    onClick,\n    mountRef,\n}) => {\n    const [selected, setSelected] = React.useState(false);\n    const hasNoMoreItems = Number(quantityLeft) === countInCart;\n\n    let badgeType = '';\n\n    if (selected) {\n        badgeType = hasNoMoreItems ? 'disabled' : 'add';\n    } else if (countInCart) {\n        badgeType = 'done';\n    }\n\n    return (\n        <div\n            tabIndex={0}\n            className={bem()}\n            onBlur={() => setSelected(false)}\n            onFocus={() => setSelected(true)}\n            onClick={onClick}\n            ref={mountRef}\n        >\n            <div className={bem('index-badge')}>{index}</div>\n            <div className={bem('thumb')} style={{ backgroundImage: `url(${imagesUrls[0]})` }} />\n            <div className={bem('description')}>\n                <div className={bem.modify({ [badgeType]: Boolean(badgeType) }, 'add-badge')} />\n                <div className={bem('description-name')}>{name}</div>\n                <div className={bem('price-container')}>\n                    <div className={bem('price')}>{Math.floor(Number(price) / 100)} ₽</div>\n                    {countInCart ? <div className={bem('count')}>×{countInCart}</div> : ''}\n                </div>\n            </div>\n        </div>\n    );\n};\n\nexport const CatalogListItem = withBem(Component, 'CatalogListItem');\n","import React from 'react';\nimport { connectToStore } from 'tools/connect';\nimport withBem from 'hoc/withBem';\nimport { StoreType } from 'stores/types';\nimport { ProductItemModel } from 'stores/product';\nimport { useFocusOnMount } from 'hooks';\n\nimport { CatalogListItem } from '../ListItem/CatalogListItem';\nimport './CatalogList.scss';\n\ninterface CatalogListProps extends StoreType, BemProps {}\n\nconst Component: React.FC<CatalogListProps> = ({ bem, products, cart }) => {\n    const mountFocusRef = useFocusOnMount<HTMLDivElement>();\n\n    return (\n        <div className={bem()}>\n            <div className={bem('container')}>\n                {products.items.map((item: ProductItemModel, index) => (\n                    <CatalogListItem\n                        {...item}\n                        mountRef={!index ? mountFocusRef : undefined}\n                        countInCart={cart.itemsMap[item.id] ? cart.itemsMap[item.id].count : 0}\n                        key={item.id}\n                        index={index + 1}\n                        onClick={() => cart.addToCart(item.id)}\n                    />\n                ))}\n            </div>\n        </div>\n    );\n};\n\nexport const CatalogList = withBem(connectToStore(Component), 'CatalogList');\n","import React from 'react';\nimport ContentLoader, { IContentLoaderProps } from 'react-content-loader';\n\ninterface SkeletonProps extends IContentLoaderProps {\n    itemWidth: number;\n    itemHeight: number;\n    borderRadius: number;\n    rowCount: number;\n    columnCount: number;\n    paddingBetweenColumns: number;\n    paddingBetweenRows: number;\n}\n\nexport const Skeleton: React.FC<SkeletonProps> = ({\n    itemWidth,\n    itemHeight,\n    borderRadius,\n    rowCount,\n    columnCount,\n    paddingBetweenColumns,\n    paddingBetweenRows,\n    ...props\n}) => {\n    const list = Array.from(Array(columnCount)).map((_, columnIndex) =>\n        Array.from(Array(rowCount)).map((_, rowIndex) => (\n            <rect\n                key={`${columnIndex} ${rowIndex}`}\n                x={columnIndex * (itemWidth + paddingBetweenColumns)}\n                y={rowIndex * (itemHeight + paddingBetweenRows)}\n                width={itemWidth}\n                height={itemHeight}\n                rx={borderRadius}\n                ry={borderRadius}\n            />\n        )),\n    );\n\n    return <ContentLoader {...props}>{list}</ContentLoader>;\n};\n","import React from 'react';\nimport { Skeleton } from 'components/Skeleton/Skeleton';\nimport withBem from 'hoc/withBem';\n\nimport './CatalogSkeleton.scss';\n\ntype CatalogSkeletonProps = BemProps;\n\nconst itemWidth = 392;\nconst itemHeight = 592;\nconst columnCount = 5;\nconst paddingBetween = 32;\n\nexport const Component: React.FC<CatalogSkeletonProps> = ({ bem }) => (\n    <div className={bem()}>\n        <Skeleton\n            viewBox={`0 0 ${itemWidth * columnCount + paddingBetween * (columnCount - 1)} ${itemHeight}`}\n            width=\"100%\"\n            height=\"100%\"\n            backgroundColor=\"#262828\"\n            foregroundColor=\"#414545\"\n            itemWidth={itemWidth}\n            itemHeight={itemHeight}\n            borderRadius={24}\n            rowCount={2}\n            columnCount={5}\n            paddingBetweenRows={paddingBetween}\n            paddingBetweenColumns={paddingBetween}\n            speed={2}\n        />\n    </div>\n);\n\nexport const CatalogSkeleton = withBem(Component, 'CatalogSkeleton');\n","import React from 'react';\nimport { SHOW_ITEMS_MOCK } from 'mocks';\nimport { Suggest } from 'components/Suggest/Suggest';\nimport { Header } from 'components/Header/Header';\nimport { HeaderAddress } from 'components/HeaderAddress/HeaderAddress';\nimport { HeaderCart } from 'components/HeaderCart/HeaderCart';\nimport { connectToStore } from 'tools/connect';\nimport { StoreType } from 'stores/types';\n\nimport { CatalogList } from './List/CatalogList';\nimport { CatalogSkeleton } from './Skeleton/CatalogSkeleton';\n\ntype CatalogProps = StoreType;\n\nconst Component: React.FC<CatalogProps> = ({ cart, products }) => {\n    React.useEffect(() => {\n        window.AssistantClient.sendData({\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            action_id: 'ASK_FOR_STOCK',\n        });\n    }, []);\n\n    React.useEffect(() => {\n        if (process.env.REACT_APP_ENVIRONMENT === 'development') {\n            window.AssistantClient.onData({\n                type: 'smart_app_data',\n                // eslint-disable-next-line\n                smart_app_data: {\n                    command: 'SHOW_ITEMS',\n                    stock: SHOW_ITEMS_MOCK,\n                },\n            });\n\n            window.AssistantClient.onData({\n                type: 'smart_app_data',\n                // eslint-disable-next-line\n                smart_app_data: {\n                    command: 'ADD_ITEM',\n                    item: '21ff407a-fa98-11e8-80c5-0cc47a817925',\n                    count: '2',\n                },\n            });\n        }\n    }, []);\n\n    return (\n        <>\n            <Header title=\"Самокат\">\n                <HeaderAddress />\n                {cart.count > 0 ? <HeaderCart /> : ''}\n            </Header>\n            {products.items.length ? <CatalogList /> : <CatalogSkeleton />}\n        </>\n    );\n};\n\nexport const Catalog = connectToStore(Component);\n","import React from 'react';\nimport withBem from 'hoc/withBem';\nimport { useFocusOnMount } from 'hooks';\n\nimport './Button.scss';\n\ninterface ButtonProps extends BemProps, React.HTMLAttributes<HTMLButtonElement> {\n    shouldFocusOnMount?: boolean;\n}\n\nconst Component: React.FC<ButtonProps> = ({ bem, children, className, shouldFocusOnMount, ...props }) => {\n    const mountFocusRef = useFocusOnMount<HTMLButtonElement>();\n\n    return (\n        <button\n            className={bem.all(bem(), className || '')}\n            ref={shouldFocusOnMount ? mountFocusRef : null}\n            type=\"button\"\n            {...props}\n        >\n            {children}\n        </button>\n    );\n};\n\nexport const Button = withBem(Component, 'Button');\n","import React from 'react';\nimport withBem from 'hoc/withBem';\nimport { connectToStore } from 'tools/connect';\nimport { Button } from 'components/Button/Button';\nimport { StoreType } from 'stores/types';\n\nimport './CartInfo.scss';\n\ninterface CartInfoProps extends BemProps, StoreType {}\n\nconst addAddressInfo = (user: StoreType['user']) =>\n    user.updateUser({\n        location: 'подъезд 1, корпус Г',\n        phoneNumber: '+7 910 345 67 89',\n        name: 'Сергей',\n    });\n\nconst Component: React.FC<CartInfoProps> = ({ bem, user, cart }) => {\n    const { phoneNumber, address, location, name } = user;\n    const hasPersonalData = phoneNumber && address && location && name;\n\n    return (\n        <div className={bem()}>\n            <div className={bem('badge')}>\n                <div className={bem('badge-body')}>\n                    <div className={bem('badge-name')}>15-30</div>\n                    <div className={bem('badge-desc')}>мин</div>\n                </div>\n                <div className={bem('badge-kernel')} />\n                <div className={bem.modify({ big: true }, 'badge-shadow')} />\n                <div className={bem.modify({ small: true }, 'badge-shadow')} />\n            </div>\n            <div className={bem('address')}>{user.address}</div>\n            {hasPersonalData ? (\n                <>\n                    <div className={bem('personal')}>\n                        <div className={bem('personal-location')}>{user.location}</div>\n                        <div className={bem('personal-phone-number')}>{user.phoneNumber}</div>\n                        <div className={bem('personal-name')}>{user.name}</div>\n                    </div>\n                    <Button\n                        className={bem.modify({ disabled: false }, 'button')}\n                        shouldFocusOnMount\n                        onClick={() => cart.makePurchase()}\n                    >\n                        Перейти к оплате\n                    </Button>\n                </>\n            ) : (\n                <>\n                    <div className={bem('ask-personal')}>\n                        Чтобы сделать заказ, укажите квартиру, подъезд и другую дополнительную информацию\n                    </div>\n                    <Button\n                        className={bem.modify({ disabled: false }, 'button')}\n                        shouldFocusOnMount\n                        onClick={() => addAddressInfo(user)}\n                    >\n                        Дополнить адрес\n                    </Button>\n                </>\n            )}\n        </div>\n    );\n};\n\nexport const CartInfo = withBem(connectToStore(Component), 'CartInfo');\n","import React from 'react';\nimport { CartItemModel } from 'stores/cart';\nimport withBem from 'hoc/withBem';\n\nimport './CartListItem.scss';\n\ninterface CartListItemProps extends CartItemModel, BemProps {\n    index: number;\n    onMoreClick: () => void;\n    onLessClick: () => void;\n    onSelect: (index: number) => void;\n}\n\nconst Component: React.FC<CartListItemProps> = ({\n    index,\n    onLessClick,\n    onMoreClick,\n    onSelect,\n    product: { imagesUrls, clearName, price, quantityLeft },\n    count,\n    bem,\n}) => {\n    const [selected, setFocus] = React.useState(false);\n    const hasNoMoreItems = Number(quantityLeft) === count;\n    const memoizedOnFocus = React.useCallback(() => {\n        onSelect(index - 1); // -1 потому что индекс сдвинут на единицу вперед\n        setFocus(true);\n    }, [onSelect, index]);\n\n    return (\n        <div className={bem()}>\n            <div className={bem('index-badge')}>{index}</div>\n            <div className={bem('image')} style={{ backgroundImage: `url(\"${imagesUrls[0]}\")` }} />\n            <div className={bem('info')}>\n                <div className={bem('name')}>{clearName}</div>\n                <div className={bem('price')}>{Math.floor(Number(price) / 100)} ₽</div>\n            </div>\n            <div className={bem.modify({ selected }, 'selector')}>\n                <button\n                    type=\"button\"\n                    aria-label=\"less\"\n                    className={bem.modify({ less: !!count, remove: !count }, 'selector-button')}\n                    onFocus={memoizedOnFocus}\n                    onBlur={() => setFocus(false)}\n                    onClick={onLessClick}\n                />\n                <div className={bem('selector-value')}>{count}</div>\n                <button\n                    type=\"button\"\n                    aria-label=\"more\"\n                    disabled={hasNoMoreItems}\n                    className={bem.modify({ more: true }, 'selector-button')}\n                    onFocus={memoizedOnFocus}\n                    onBlur={() => setFocus(false)}\n                    onClick={onMoreClick}\n                />\n            </div>\n        </div>\n    );\n};\n\nexport const CartListItem = withBem(Component, 'CartListItem');\n","import React from 'react';\nimport { connectToStore } from 'tools/connect';\nimport { splitByThousands } from 'tools';\nimport { StoreType } from 'stores/types';\nimport { SHOW_ITEMS_MOCK } from 'mocks';\nimport withBem from 'hoc/withBem';\n\nimport { CartListItem } from '../ListItem/CartListItem';\n\nimport './CartList.scss';\n\ninterface CartListProps extends StoreType, BemProps {}\n\nconst ITEM_WIDTH = 152;\n\nconst onScroll = (e: React.UIEvent<HTMLDivElement>) => {\n    e.currentTarget.scrollTop = 0;\n};\n\nconst getOffset = (index: number, itemsCount: number) => {\n    // так как индекс начинается с 0, то расчеты бы имели смысл начиная\n    // со второго элемента (индекс = 1), но нам нужно начинать скролл с\n    // 3-го элемента, поэтому сдвигаем значение на 1\n    let relatedIndex = Math.max(0, index - 1);\n\n    // ограничиваем максимальное значение индекса\n    relatedIndex = Math.min(Math.max(0, itemsCount - 4), relatedIndex);\n\n    // домножаем отступ на коэффициент высоты айтема\n    return relatedIndex * ITEM_WIDTH;\n};\n\nconst Component: React.FC<CartListProps> = ({ cart, bem }) => {\n    const { items } = cart;\n    const [selectedItemIndex, setSelectedItemIndex] = React.useState(0);\n    const isFirstItemSelected = !selectedItemIndex;\n    const isLastItemSelected = selectedItemIndex === items.length - 1;\n\n    const wrapperStyle: React.CSSProperties = {\n        transform: `translateY(-${getOffset(selectedItemIndex, items.length)}px)`,\n    };\n\n    React.useEffect(() => {\n        if (process.env.REACT_APP_ENVIRONMENT === 'development') {\n            window.AssistantClient.onData({\n                type: 'smart_app_data',\n                // eslint-disable-next-line\n                smart_app_data: {\n                    command: 'SHOW_ITEMS',\n                    stock: SHOW_ITEMS_MOCK,\n                },\n            });\n\n            [\n                { item: '21ff4078-fa98-11e8-80c5-0cc47a817925', count: 5 },\n                { item: '21ff407a-fa98-11e8-80c5-0cc47a817925', count: 4 },\n                { item: '2ff0d82c-681c-11e9-80c5-0cc47a817925', count: 2 },\n                { item: '21ff407c-fa98-11e8-80c5-0cc47a817925', count: 5 },\n            ].map(({ item, count }) =>\n                window.AssistantClient.onData({\n                    type: 'smart_app_data',\n                    // eslint-disable-next-line\n                    smart_app_data: {\n                        command: 'ADD_ITEM',\n                        item,\n                        count,\n                    },\n                }),\n            );\n        }\n    }, []);\n\n    return (\n        <div className={bem()}>\n            <div className={bem('container')} onScroll={onScroll}>\n                <div\n                    className={bem.modify({ top: true, hidden: items.length <= 4 || isFirstItemSelected }, 'gradient')}\n                />\n                <div className={bem('wrapper')} style={wrapperStyle}>\n                    {items.map((item, index) => (\n                        <CartListItem\n                            {...item}\n                            onSelect={setSelectedItemIndex}\n                            onLessClick={() =>\n                                cart.removeFromCart({\n                                    itemId: item.product.id,\n                                    count: 1,\n                                    shouldRemoveMention: !item.count,\n                                })\n                            }\n                            onMoreClick={() => cart.addToCart(item.product.id)}\n                            index={index + 1}\n                            key={item.product.id}\n                        />\n                    ))}\n                </div>\n                <div\n                    className={bem.modify(\n                        { bottom: true, hidden: items.length <= 4 || isLastItemSelected },\n                        'gradient',\n                    )}\n                />\n            </div>\n            <div className={bem('total-price')}>Сумма заказа {splitByThousands(String(cart.totalPrice))} ₽</div>\n        </div>\n    );\n};\n\nexport const CartList = withBem(connectToStore(Component), 'CartList');\n","import React from 'react';\nimport { Header } from 'components/Header/Header';\nimport { connectToStore } from 'tools/connect';\nimport { StoreType } from 'stores/types';\nimport withBem from 'hoc/withBem';\n\nimport { CartInfo } from './Info/CartInfo';\nimport { CartList } from './List/CartList';\nimport './Cart.scss';\n\ninterface CartProps extends StoreType, BemProps {}\n\nconst Component: React.FC<CartProps> = ({ bem }) => (\n    <>\n        <div className={bem('background')} />\n        <Header title=\"Корзина\" />\n        <div className={bem('container')}>\n            <CartList />\n            <CartInfo />\n        </div>\n    </>\n);\n\nexport const Cart = withBem(connectToStore(Component), 'Cart');\n","import React from 'react';\nimport { Header } from 'components/Header/Header';\nimport { Button } from 'components/Button/Button';\nimport { StoreType } from 'stores/types';\nimport withBem from 'hoc/withBem';\nimport { connectToStore } from 'tools/connect';\n\nimport './Status.scss';\n\ninterface StatusProps extends BemProps, StoreType {}\n\nconst Component: React.FC<StatusProps> = ({ cart, bem }) => (\n    <>\n        <Header title=\"Самокат\" />\n        <div className={bem('container')}>\n            <div className={bem('order-number')}>Заказ #{cart.orderId} оформлен</div>\n            <div className={bem('order-time')}>\n                Спасибо за заказ!\n                <br />\n                Будем у вас через 15-30 минут.\n            </div>\n            <Button className={bem('success-button')} shouldFocusOnMount>\n                Очень жду\n            </Button>\n            <div className={bem('figure-1')} />\n            <div className={bem('figure-2')} />\n            <div className={bem('figure-3')} />\n            <div className={bem('figure-4')} />\n            <div className={bem('figure-5')} />\n            <div className={bem('figure-6')} />\n            <div className={bem('figure-7')} />\n            <div className={bem('figure-8')} />\n            <div className={bem('figure-9')} />\n        </div>\n    </>\n);\n\nexport const Status = withBem(connectToStore(Component), 'Status');\n","import React from 'react';\nimport withBem from 'hoc/withBem';\nimport { useFocusOnMount, useInterval } from 'hooks';\nimport { Button } from 'components/Button/Button';\n\nimport './Promo.scss';\n\ntype PromoProps = BemProps;\n\nconst POPCORN_TYPES_COUNT = 4;\n\nconst Component: React.FC<PromoProps> = ({ bem }) => {\n    const mountRef = useFocusOnMount<HTMLButtonElement>();\n    const [currentIndex, setIndex] = React.useState(0);\n    useInterval(() => setIndex(currentIndex === POPCORN_TYPES_COUNT - 1 ? 0 : currentIndex + 1), 3000);\n\n    return (\n        <div className={bem.modify({ [`type-${currentIndex + 1}`]: true })}>\n            <div className={bem('glow')}>\n                <div className={bem.modify({ [`type-${currentIndex + 1}`]: true }, 'glow-1')} />\n                <div className={bem.modify({ [`type-${currentIndex + 1}`]: true }, 'glow-2')} />\n                <div className={bem.modify({ [`type-${currentIndex + 1}`]: true }, 'glow-3')} />\n                <div className={bem.modify({ [`type-${currentIndex + 1}`]: true }, 'glow-4')} />\n            </div>\n            <div className={bem('title')}>\n                Попкорн и напитки\n                <br />к просмотру фильмов\n                <br />и сериалов\n            </div>\n            <div className={bem('subtitle')}>\n                Доставим бесплатно в течении 15-30 минут для Москвы и Санкт-Петербурга\n            </div>\n            {Array.from(Array(POPCORN_TYPES_COUNT)).map((_, index) => (\n                <div\n                    key={index}\n                    className={bem.modify({ [`type-${index + 1}`]: true, hidden: index !== currentIndex }, 'image')}\n                />\n            ))}\n            <div className={bem('button-container')}>\n                <Button className={bem('button')} shouldFocusOnMount>\n                    Указать адрес\n                </Button>\n                <Button className={bem('button')}>Не сейчас</Button>\n            </div>\n        </div>\n    );\n};\n\nexport const Promo = withBem(Component, 'Promo');\n","import React from 'react';\n\nexport const useInterval = (callback: (...args: any[]) => void, timeout: number) =>\n    React.useEffect(() => {\n        const intervalId = setInterval(callback, timeout);\n\n        return () => clearInterval(intervalId);\n    });\n","import React from 'react';\nimport { Header } from 'components/Header/Header';\nimport { Button } from 'components/Button/Button';\nimport withBem from 'hoc/withBem';\nimport { connectToStore } from 'tools/connect';\nimport { StoreType } from 'stores/types';\n\nimport './NoArea.scss';\n\ninterface NoAreaProps extends BemProps, StoreType {}\n\nconst Component: React.FC<NoAreaProps> = ({ bem, user }) => (\n    <div className={bem()}>\n        <Header className={bem('header')} title=\"Адрес доставки\" />\n        <div className={bem('container')}>\n            <div className={bem('badge')}>\n                <div className={bem('badge-body')} />\n                <div className={bem('badge-kernel')} />\n                <div className={bem.modify({ big: true }, 'badge-shadow')} />\n                <div className={bem.modify({ small: true }, 'badge-shadow')} />\n            </div>\n            <div className={bem('title')}>{user.address}</div>\n            <div className={bem('subtitle')}>К сожалению, пока не доставляем по этому адресу</div>\n            <Button shouldFocusOnMount className={bem('button')}>\n                Изменить\n            </Button>\n        </div>\n        <div className={bem('background')} />\n    </div>\n);\n\nexport const NoArea = withBem(connectToStore(Component), 'NoArea');\n","import React from 'react';\nimport withBem from 'hoc/withBem';\n\nimport './ScreenSaver.scss';\n\ntype ScreenSaverProps = BemProps;\n\nconst Component: React.FC<ScreenSaverProps> = ({ bem }) => (\n    <div className={bem()}>\n        Это скринсейвер\n        <br />\n        Здесь будет роскошный прелоадер с попкорном\n    </div>\n);\n\nexport const ScreenSaver = withBem(Component, 'ScreenSaver');\n","import React from 'react';\nimport { Header } from 'components/Header/Header';\nimport withBem from 'hoc/withBem';\n\nimport './AddressSimple.scss';\n\ntype AddressSimpleProps = BemProps;\n\nexport const Component: React.FC<AddressSimpleProps> = ({ bem }) => (\n    <>\n        <Header title=\"Адрес доставки\" />\n        <div className={bem('container')}>\n            <input type=\"text\" />\n        </div>\n    </>\n);\n\nexport const AddressSimple = withBem(Component, 'AddressSimple');\n","import React from 'react';\nimport { Redirect, Route, Switch } from 'react-router-dom';\nimport { Catalog } from 'pages/Catalog/Catalog';\nimport { Cart } from 'pages/Cart/Cart';\nimport { Status } from 'pages/Status/Status';\nimport { Promo } from 'pages/Promo/Promo';\nimport { NoArea } from 'pages/NoArea/NoArea';\nimport { ScreenSaver } from 'pages/ScreenSaver/ScreenSaver';\nimport { AddressSimple } from 'pages/AddressSimple/AddressSimple';\nimport withBem from 'hoc/withBem';\nimport { routes } from 'stores/ui';\nimport 'style/global.scss';\nimport 'normalize.css/normalize.css';\n\nimport './Root.scss';\n\ntype RootProps = BemProps;\n\nconst Component: React.FC<RootProps> = ({ bem }) => {\n    // эти костыли со стилями нужны для того, чтобы верстка норм смотрелась на планшете\n    // там разрешение экрана ~600X300 px\n    let containerStyle = {};\n    let wrapperStyle = {};\n\n    if (process.env.REACT_APP_ENVIRONMENT === 'staging') {\n        containerStyle = {\n            transform: 'scale(0.4)',\n            height: '1080px',\n            width: '1920px',\n        };\n\n        wrapperStyle = {\n            transform: 'translate(-580px, -310px)',\n        };\n    }\n\n    return (\n        <div style={wrapperStyle}>\n            <div style={containerStyle} className={bem()}>\n                <Switch>\n                    <Route path={routes.CATALOG}>\n                        <Catalog />\n                    </Route>\n                    <Route path={routes.CART}>\n                        <Cart />\n                    </Route>\n                    <Route path={routes.STATUS}>\n                        <Status />\n                    </Route>\n                    <Route path={routes.ADDRESS_SIMPLE}>\n                        <AddressSimple />\n                    </Route>\n                    <Route path={routes.PROMO}>\n                        <Promo />\n                    </Route>\n                    <Route path={routes.NO_AREA}>\n                        <NoArea />\n                    </Route>\n                    <Route path={routes.SCREEN_SAVER}>\n                        <ScreenSaver />\n                    </Route>\n                    <Redirect to={routes.SCREEN_SAVER} />\n                </Switch>\n            </div>\n        </div>\n    );\n};\n\nexport const Root = withBem(Component, 'Root');\n","import 'core-js';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Router } from 'react-router-dom';\nimport history from 'tools/history';\nimport store from 'stores';\nimport { setStore } from 'tools/connect';\nimport { Root } from 'components/Root/Root';\n\nimport 'tools/new-spatial-navigation';\n\nsetStore(store);\n\nif (process.env.REACT_APP_ENVIRONMENT === 'development') {\n    window.store = store;\n    const makeInspectable = require('mobx-devtools-mst'); // eslint-disable-line\n    makeInspectable.default(store);\n}\n\nconst APP_ROOT_ID = 'application_root';\n\nexport function renderApp(App: React.FC) {\n    ReactDOM.render(\n        <Router history={history}>\n            <App />\n        </Router>,\n        document.getElementById(APP_ROOT_ID),\n    );\n}\n\nrenderApp(Root);\n\nif (process.env.REACT_APP_ENVIRONMENT !== 'production' && module.hot) {\n    module.hot.accept('./components/Root/Root', () => {\n        // eslint-disable-next-line\n        const { Root } = require('./components/Root/Root.tsx');\n        renderApp(Root);\n    });\n}\n"],"sourceRoot":""}